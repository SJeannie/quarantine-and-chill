"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Pipe = undefined;

var _iterators = require("./iterators");

var _EventEmitter = require("./EventEmitter");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const execute = Symbol();
const pending = Symbol();

class Pipe {
  constructor(_process, ..._args) {
    _defineProperty(this, "latency", false);

    _defineProperty(this, "listeners", []);

    _defineProperty(this, "observers", []);

    _defineProperty(this, "dependencies", []);

    _defineProperty(this, "errorHandlers", []);

    _defineProperty(this, "cancelationHandlers", []);

    _defineProperty(this, "executions", []);

    _defineProperty(this, "currentValue", pending);

    _defineProperty(this, "resources", {});

    _defineProperty(this, "emit", async (...args) => {
      this.currentValue = args[0];
      let listeners = [...this.listeners];
      let observers = [...this.observers];
      this.listeners = [];
      await Promise.all([...listeners.map(listener => listener(...args)), ...observers.map(observer => observer(...args))]);
    });

    _defineProperty(this, "throwError", err => {
      this.currentValue = err;
      this.errorHandlers.forEach(handler => handler(err));
    });

    _defineProperty(this, execute, async () => {
      let cursor;
      let aborted = false;

      let abortThis = () => aborted = true;

      let index = 0;
      this.executions.push(abortThis);

      let emit = (...args) => {
        if (aborted) return;

        while (this.executions.length && this.executions[0] != abortThis) {
          let abort = this.executions.shift();
          abort();
        }

        this.executions.shift();
        this.emit(...args);
      };

      emit.throw = this.throwError;
      emit.pipe = this;

      try {
        cursor = this.process.call(this.thisArg, emit, ...this.args);
      } catch (err) {
        this.throwError(err);
      }

      const process = ({
        value,
        done
      }) => {
        const {
          isPipe,
          isPromise,
          isObservable
        } = this.constructor;
        const {
          cached,
          cache
        } = this;
        const cachedPromise = cached(value);

        const throwError = err => {
          if (cursor.throw) {
            return process(cursor.throw(err));
          } else {
            return this.throwError(err);
          }
        };

        let next;
        if (done && value === undefined) return;
        if (done) next = (...args) => !aborted && emit(...args);else next = (...args) => !aborted && moveCursor(...args);
        return new Promise(async () => {
          if (cachedPromise) cachedPromise.currentValue instanceof Error ? throwError(cachedPromise.currentValue) : await next(await cachedPromise);else if (isPipe(value)) {
            this.dependencies.push(value);
            value.apply(result => {
              cache(value);
              next(result);
            }, err => {
              cache(value);
              throwError(err);
            });
          } else if (isPromise(value)) {
            await value.then(next).catch(err => throwError(err));
          } else {
            index++;
            const cachedResource = this.getCachedResource(value, index);

            if (cachedResource) {
              await next(cachedResource);
            } else {
              if (!done) this.cacheResource(value, index);
              await next(value);
            }
          }
        });
      };

      const moveCursor = result => {
        try {
          result = cursor.next(result);
          process(result);
        } catch (err) {
          this.throwError(err);
        }
      };

      if (cursor && typeof cursor.next == 'function') await moveCursor();else await process({
        value: cursor,
        done: true
      });
    });

    _defineProperty(this, "cache", pipe => {
      let observer = err => {
        if ((this.observers.length || this.listeners.length) && !this.isCanceled) {
          if (this.latency === false) this[execute]();else if (!this.timer) this.timer = setTimeout(() => {
            this[execute]();
            this.timer = false;
          }, this.latency);
        }
      };

      pipe.catch(observer);
      pipe.observe(observer);
      this.onCancel(() => pipe.unobserve(observer));
    });

    _defineProperty(this, "cached", pipe => {
      let cachedPipe = this.dependencies.find(dependency => dependency.isEqual(pipe));

      if (cachedPipe) {
        if (cachedPipe !== pipe) {
          pipe.destroy();
        }

        return cachedPipe;
      }
    });

    _defineProperty(this, "getCachedResource", (resource = {}, index) => {
      if (!resource) return;
      let id = resource.uid || `${index}`;
      return this.resources[id];
    });

    _defineProperty(this, "isEqual", pipe => pipe && pipe.process == this.process && JSON.stringify(pipe.args) === JSON.stringify(this.args) && (pipe.thisArg == this.thisArg || !pipe.thisArg || !this.thisArg || this.thisArg.id == pipe.thisArg.id));

    let thisArg;

    if (Array.isArray(_process)) {
      thisArg = _process[0];
      _process = _process[1];
    }

    this.process = _process;
    this.thisArg = thisArg;
    this.args = _args;
    setTimeout(() => {
      if (!this.alreadyInitialized && !this.isCanceled) this[execute]();
    });
  }

  observe(callback) {
    if (this.cachedValue) callback(this.cachedValue);
    this.observers.push(callback);
    return this;
  }

  unobserve(callback) {
    this.observers = this.observers.filter(observer => observer != callback);

    if (this.observers.length == 0) {
      this.destroy();
    }
  }

  then(callback, errorHandler = () => void 0) {
    if (this.currentValue !== pending) return this.currentValue instanceof Error ? errorHandler(this.currentValue) : callback(this.currentValue);

    let catchHandler = err => {
      this.errorHandlers = this.errorHandlers.filter(handler => handler != catchHandler);
      errorHandler(err);
    };

    this.catch(catchHandler);

    let resolve = () => resolve = true;

    this.listeners.push(async (...args) => {
      this.errorHandlers = this.errorHandlers.filter(handler => handler != catchHandler);
      if (resolve !== true) await callback(...args);
      resolve();
    });
    return new Promise(ref => resolve === true ? ref() : resolve = ref);
  }

  catch(callback) {
    this.errorHandlers.push(callback);
  }

  onCancel(callback) {
    if (this.isCanceled) callback();else this.cancelationHandlers.push(callback);
  }

  apply(callback, errorHandler = () => void 0) {
    if (this.currentValue != pending) {
      if (this.currentValue instanceof Error) errorHandler(this.currentValue);else callback(this.currentValue);
    } else {
      this.then(callback, errorHandler);
      this.alreadyInitialized = true;
      this[execute]();
    }
  }

  forceReload() {
    this[execute]();
  }

  destroy() {
    this.isCanceled = true;
    this.cancelationHandlers.forEach(callback => callback());
  }

  cacheResource(resource, index) {
    if (!resource) return resource;
    let id;

    if (resource.uid) {
      id = resource.uid;
    } else {
      id = `${index}`;

      if (this.currentValue != pending && this.resources[id] === undefined) {
        throw Error('A new resource without a uid was conditionally yielded. This behavior is not supported, as TriFrame will not know where to properly yield state. Please give your resources unique `uid` properties');
      }
    }

    this.resources[id] = resource;
    const agent = new _EventEmitter.EventEmitter();

    const monitor = node => {
      if (node && typeof node.on === 'function') node.on('Î”.change', () => agent.emit(`change`));else if (isPlain(node)) (0, _iterators.each)(node, (key, value) => {
        Object.defineProperty(node, key, {
          enumerable: true,
          get: () => value,
          set: newValue => {
            value = newValue;
            agent.emit(`change`);
          }
        });
      });
    };

    this.cache(agent.on('change'));
    crawl(resource, monitor);
  }

  debounce(latency = 0) {
    this.latency = latency;
    return this;
  }

  toJSON() {
    return {};
  }

}

exports.Pipe = Pipe;

_defineProperty(Pipe, "isPipe", value => value && typeof value.observe == 'function');

_defineProperty(Pipe, "isPromise", value => value && typeof value.then == 'function');

const primativeTypes = ['String', 'Boolean', 'Number', 'Date', 'Function'];

const isPlain = value => value && typeof value === 'object' && !primativeTypes.includes(value.constructor.name) && typeof value.on !== 'function';

const crawl = (obj, callback) => {
  callback(obj);

  if (isPlain(obj)) {
    for (let key in obj) {
      callback(obj[key]);
      let value = obj[key];
      crawl(value, callback);
    }
  }
};
//# sourceMappingURL=Pipe.js.map