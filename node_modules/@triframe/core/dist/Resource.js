"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Resource = undefined;

var _EventEmitter = require("./EventEmitter");

var _iterators = require("./iterators");

var _inflection = require("./inflection");

var _deepClone = require("./deepClone");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const batchFlag = Symbol();

class Resource extends _EventEmitter.EventEmitter {
  static on(event, callback) {
    if (Array.isArray(event)) event = event.map(event => `${this.name}.${event}`);else event = `${this.name}.${event}`;
    return this.events.on(event, callback);
  }

  static emit(event, ...args) {
    console.log(`Emitting: ${this.name}.${event}`);
    return this.events.emit(`${this.name}.${event}`, ...args);
  }

  static nowAndOn(event, callback) {
    if (Array.isArray(event)) event = event.map(event => `${this.name}.${event}`);else event = `${this.name}.${event}`;
    return this.events.nowAndOn(event, callback);
  }

  emit(event, ...args) {
    if (this[batchFlag] && event == 'Δ.change') return null;else return super.emit(event, ...args);
  }

  startBatchUpdate() {
    this[batchFlag] = true;
  }

  commitBatchUpdate() {
    this[batchFlag] = false;
    this.emit('Δ.change');
  }

  constructor(attributes = {}) {
    super(); // [[base]] + [[patches]] = [[attributes]]

    Object.defineProperty(this, '[[attributes]]', {
      writable: true,
      enumerable: false,
      value: attributes
    });
    Object.defineProperty(this, '[[base]]', {
      writable: true,
      enumerable: false,
      value: (0, _deepClone.deepClone)(attributes)
    });
    Object.defineProperty(this, '[[patches]]', {
      writable: true,
      enumerable: false,
      value: []
    });
    Object.defineProperty(this, '[[batch]]', {
      writable: true,
      enumerable: false,
      value: 1
    });
    Object.defineProperty(this, '[[syncRate]]', {
      writable: true,
      enumerable: false,
      value: 0
    });
    Object.defineProperty(this, 'toJSON', {
      value: function () {
        return this['[[attributes]]'];
      }
    });
    Resource.events.emit('initialized', this);
  }

  get uid() {
    return this.id !== undefined ? `${this.constructor.name}.${this.id}` : null;
  }

  get validation() {
    return this['[[validation]]'].for(this);
  }

  set(attributes) {
    let patches = [];
    (0, _iterators.each)(attributes, (key, value) => {
      let patch = {
        op: 'replace',
        path: `/${key}`,
        value
      };
      patches.push(patch);
    });
    this.emit('Δ.change', patches);
    this['[[patches]]'].push(...patches);
    Object.assign(this['[[attributes]]'], attributes);
  }

}

exports.Resource = Resource;

_defineProperty(Resource, "events", new _EventEmitter.EventEmitter());

let validators = {};
Object.defineProperty(Resource.prototype, '[[validation]]', {
  // writable: true,
  enumerable: false,
  get: function () {
    validators[this.constructor.name] = validators[this.constructor.name] || createResourceValidator();
    return validators[this.constructor.name];
  }
});

function createResourceValidator() {
  let handlers = {};
  return {
    handlers,
    for: resource => {
      if (!resource['[[validationState]]']) Object.defineProperty(resource, '[[validationState]]', {
        enumerable: false,
        value: {}
      });
      let showValidation = resource['[[validationState]]'];

      const hasErrors = propertyName => {
        return errorsFor(propertyName).length > 0;
      };

      const errorsFor = propertyName => {
        const validators = handlers[propertyName];

        if (validators !== undefined) {
          const property = resource[propertyName];
          const errors = [];
          const label = (0, _inflection.toTitleCase)(propertyName);
          validators.forEach(validator => validator.call(resource, {
            property,
            label,
            errors,
            resource
          }));
          return errors;
        } else {
          return [];
        }
      };

      const validator = {
        addHandler: (propertyName, validator) => {
          if (typeof validator != 'function') throw Error(`Validators must be functions, received '${validator}'`);
          handlers[propertyName] = handlers[propertyName] || [];
          handlers[propertyName].push(validator);
        },
        errorMessageFor: (propertyName, label = (0, _inflection.toTitleCase)((0, _inflection.toHumanized)((0, _inflection.toUnderscored)(propertyName)))) => {
          let errors = errorsFor(propertyName);
          if (errors.length === 0) return ' ';
          if (errors.length === 1) return `${label} ${errors[0]}`;
          let lastError = errors.pop();
          return `${label} ${errors.join(', ')} and ${lastError}`;
        },

        get allErrorMessages() {
          let messages = [];
          (0, _iterators.each)(handlers, propertyName => {
            let message = this.errorMessageFor(propertyName);
            if (message) messages.push(message);
          });
          return messages;
        },

        shouldShowErrorsFor: propertyName => {
          return showValidation[propertyName] === true && hasErrors(propertyName);
        },
        showErrorsFor: propertyName => {
          showValidation[propertyName] = true;
          resource.emit('Δ.change');
        },
        hideErrorsFor: propertyName => {
          showValidation[propertyName] = false; //resource.emit('Δ.change')
        },
        showAllErrors: () => {
          (0, _iterators.each)(handlers, propertyName => {
            showValidation[propertyName] = true;
          });
          resource.emit('Δ.change');
        },
        hideAllErrors: () => {
          (0, _iterators.each)(handlers, propertyName => {
            showValidation[propertyName] = false;
          });
          resource.emit('Δ.change');
        },

        get isInvalid() {
          let isInvalid = false;
          (0, _iterators.each)(handlers, propertyName => {
            isInvalid = isInvalid || hasErrors(propertyName);
          });
          return isInvalid;
        },

        get isValid() {
          return !validator.isInvalid;
        }

      };
      return validator;
    }
  };
}
//# sourceMappingURL=Resource.js.map