"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tether = exports.Provider = exports.Model = undefined;

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _reactRouter = require("react-router");

var _core = require("@triframe/core");

var _arbiter = require("@triframe/arbiter");

var _Router = require("./Router");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const Model = exports.Model = _react2.default.createContext({
  areReady: false
});

const Provider = exports.Provider = props => /*#__PURE__*/_react2.default.createElement(_Router.Router, null, /*#__PURE__*/_react2.default.createElement(Main, props));

let displayError;

const Main = ({
  children,
  url,
  storage = null
}) => {
  if (storage === null && typeof localStorage !== 'undefined') storage = localStorage;
  let error;
  [error, displayError] = (0, _react.useState)(false);
  let [models, saveModels] = (0, _react.useState)({
    areReady: false
  });
  (0, _react.useEffect)(() => {
    (0, _arbiter.connect)(url, {
      storage
    }).then(models => {
      saveModels(models);
      if (typeof window !== 'undefined') Object.assign(window, models);
    });
    if (typeof window !== 'undefined') window.resetSocket = () => {
      io.socket.reconnect();
    };
  }, []);
  return /*#__PURE__*/_react2.default.createElement(Model.Provider, {
    value: models
  }, children);
};

const savedContexts = [];

const createUseContext = ({
  models,
  useRouter,
  useParams
}) => context => {
  let pipe;
  let cached = savedContexts.find(cached => cached.context === context);

  if (cached) {
    pipe = cached.pipe;
  } else {
    let useContext = createUseContext({
      useRouter,
      useParams,
      models
    });
    let Api = models;
    let payload = {
      Api,
      models,
      useContext,
      useRouter,
      useParams
    };
    pipe = new _core.Pipe(() => context(payload));
    savedContexts.push({
      context,
      pipe
    });
  }

  return pipe;
};

const tether = exports.tether = Component => props => {
  return /*#__PURE__*/_react2.default.createElement(Model.Consumer, null, models => /*#__PURE__*/_react2.default.createElement(ConnectedComponent, {
    props: props,
    models: models,
    Component: Component
  }));
};

let ConnectedComponent = (0, _reactRouter.withRouter)(({
  props = [],
  models,
  Component,
  history,
  match,
  location
}) => {
  let jsx = null;
  let pipe = null;
  let propsArray = Object.values(props); //.map(prop => JSON.stringify(prop))

  const [processedProps] = (0, _react.useState)([]);
  const [agent] = (0, _react.useState)(new _core.EventEmitter());
  const [data, dispatch] = (0, _react.useState)({
    jsx,
    pipe
  });
  ({
    jsx,
    pipe
  } = data);

  const getHistory = emit => {
    emit({
      history,
      match
    });
    agent.on('history', ({
      history,
      match
    }) => emit({
      history,
      match
    }));
  };

  const getParams = emit => {
    emit(match.params);
    agent.on('history', ({
      history,
      match
    }) => emit(match.params));
  };

  (0, _react.useEffect)(() => {
    agent.emit('history', {
      history,
      match
    });
  }, [match]);
  (0, _react.useEffect)(() => {
    agent.emit('props', props);
    propsArray.forEach(prop => {
      if (prop && typeof prop.on === 'function' && !processedProps.includes(prop)) {
        processedProps.push(prop);
        prop.on('Δ.changed', () => {
          agent.emit('props', props);
        });
      }
    });
  }, propsArray);
  (0, _react.useEffect)(() => {
    if (models.areReady === false) return;

    let whileLoading = jsx => dispatch({
      jsx
    });

    let useRouter = () => new _core.Pipe(getHistory);

    let useParams = () => new _core.Pipe(getParams);

    let useContext = createUseContext({
      models,
      useRouter,
      useParams
    });

    let redirect = path => history.push(path);

    let defaultErrorHandler = err => {
      displayError(err);
    };

    let handleError = defaultErrorHandler;

    let onError = callback => handleError = err => callback(err, defaultErrorHandler);

    let catchErrors = callback => (...args) => {
      try {
        let result = callback(...args);
        if (result instanceof Promise) result.catch(handleError);
      } catch (err) {
        handleError(err);
      }
    };

    let runAfterRender, runAfterFirstRender;

    let afterRender = callback => runAfterRender = callback;

    let afterFirstRender = callback => runAfterFirstRender = callback;

    let Api = models;
    let payload = {
      Api,
      models,
      props,
      redirect,
      useContext,
      useRouter,
      useParams,
      whileLoading,
      onError,
      catchErrors,
      afterRender,
      afterFirstRender
    };
    agent.on('props', props => {
      payload.props = props;
      if (pipe) pipe.forceReload();
    });
    pipe = new _core.Pipe(x => Component(payload), payload); //.debounce()

    pipe.observe(jsx => {
      dispatch({
        jsx,
        runAfterRender,
        runAfterFirstRender,
        pipe
      });
    });
    pipe.catch(err => {
      throw err;
    });
    return () => pipe && pipe.destroy();
  }, [models.areReady]);
  (0, _react.useEffect)(() => {
    if (typeof data.runAfterRender == 'function') data.runAfterRender();
  });
  (0, _react.useEffect)(() => {
    if (typeof data.runAfterFirstRender == 'function') data.runAfterFirstRender();
  }, [data.runAfterFirstRender !== undefined]);
  return jsx;
});

let createObservable = resource => {
  const agent = new _core.EventEmitter();

  const monitor = node => {
    if (typeof node.on === 'function') node.on('Δ.change', () => agent.emit(`change`));else if (isPlain(node)) (0, _core.each)(node, (key, value) => {
      Object.defineProperty(node, key, {
        enumerable: true,
        get: () => value,
        set: newValue => {
          value = newValue;
          agent.emit(`change`);
        }
      });
    });
  };

  crawl(resource, monitor);
  return agent.on('change');
};

const primativeTypes = ['String', 'Boolean', 'Number', 'Date', 'Function'];

const isPlain = value => value && typeof value === 'object' && !primativeTypes.includes(value.constructor.name) && typeof value.on !== 'function';

const crawl = (obj, callback) => {
  callback(obj);

  if (isPlain(obj)) {
    for (let key in obj) {
      callback(obj[key]);
      let value = obj[key];
      crawl(value, callback);
    }
  }
};
//# sourceMappingURL=Provider.js.map