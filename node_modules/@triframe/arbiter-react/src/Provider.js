import React, { useState, useEffect, useMemo } from 'react';
import { withRouter } from 'react-router'
import { Pipe, EventEmitter, each } from '@triframe/core';
import { connect } from '@triframe/arbiter'
import { Router } from './Router'


export const Model = React.createContext({ areReady: false })

export const Provider = (props) => (
    <Router>
        <Main {...props} />
    </Router>
)


let displayError;

const Main = ({ children, url,storage = null }) => {
    if(storage === null && typeof localStorage !== 'undefined') storage = localStorage
    let error;
    ([error, displayError] = useState(false))
    let [models, saveModels] = useState({ areReady: false })
    useEffect(() => {
        connect(url, { storage }).then(models => {
            saveModels(models)
            if (typeof window !== 'undefined') Object.assign(window, models)
        })
        if (typeof window !== 'undefined') window.resetSocket = () => {
            io.socket.reconnect()
        }
    }, [])
    return (
        <Model.Provider value={models}>
            {children}
        </Model.Provider>
    )
}

const savedContexts = []

const createUseContext = ({models, useRouter, useParams }) => context => {
    let pipe;
    let cached = savedContexts.find(cached => cached.context === context)
    if (cached) {
        pipe = cached.pipe
    } else {
        let useContext = createUseContext({useRouter, useParams, models})
        let Api = models
        let payload = { Api, models, useContext, useRouter, useParams }
        pipe = new Pipe(() => context(payload))
        savedContexts.push({ context, pipe })
    }
    return pipe
}

export const tether = Component => props => {
    return (
        <Model.Consumer>
            {models => <ConnectedComponent props={props} models={models} Component={Component} />}
        </Model.Consumer>
    )
}

let ConnectedComponent = withRouter(({ props = [], models, Component, history, match, location }) => {
    let jsx = null
    let pipe = null

    let propsArray = Object.values(props) //.map(prop => JSON.stringify(prop))

    const [processedProps] = useState([])

    const [agent] = useState(new EventEmitter)

    const [data, dispatch] = useState({ jsx, pipe });

    ({ jsx, pipe } = data)

    const getHistory = (emit) => {
        emit({ history, match })
        agent.on('history', ({ history, match }) => emit({ history, match }))
    }

    const getParams = (emit) => {
        emit(match.params)
        agent.on('history', ({ history, match }) => emit(match.params))
    }

    useEffect(() => {
        agent.emit('history', { history, match })
    }, [match])

    useEffect(() => {
        agent.emit('props', props)
        propsArray.forEach(prop => {
            if (prop && typeof prop.on === 'function' && !processedProps.includes(prop)) {
                processedProps.push(prop)
                prop.on('Δ.changed', () => {
                    agent.emit('props', props)
                })
            }
        })
    }, propsArray)

    useEffect(() => {

        if (models.areReady === false) return

        let whileLoading = (jsx) => dispatch({ jsx })

        let useRouter = () => new Pipe(getHistory)
        let useParams = () => new Pipe(getParams)
        let useContext = createUseContext({models, useRouter, useParams })
        let redirect = path => history.push(path)

        let defaultErrorHandler = (err) => {
            displayError(err)
        }

        let handleError = defaultErrorHandler

        let onError = callback => handleError = err => callback(err, defaultErrorHandler)

        let catchErrors = callback => (...args) => {
            try {
                let result = callback(...args)
                if (result instanceof Promise) result.catch(handleError)
            } catch (err) {
                handleError(err)
            }
        }

        let runAfterRender, runAfterFirstRender;
        let afterRender = callback => runAfterRender = callback
        let afterFirstRender = callback => runAfterFirstRender = callback
    
        let Api = models

        let payload = { Api, models, props, redirect, useContext, useRouter, useParams, whileLoading, onError, catchErrors, afterRender, afterFirstRender }

        agent.on('props', props => {
            payload.props = props
            if (pipe) pipe.forceReload()
        })

        pipe = new Pipe((x) => Component(payload), payload)//.debounce()

        pipe.observe(jsx => {
            dispatch({ jsx, runAfterRender, runAfterFirstRender, pipe })
        })

        pipe.catch(err => { throw err })
        return () => pipe && pipe.destroy()

    }, [models.areReady])
    useEffect(() => {
        if (typeof data.runAfterRender == 'function') data.runAfterRender()
    })
    useEffect(() => {
        if (typeof data.runAfterFirstRender == 'function') data.runAfterFirstRender()
    }, [ data.runAfterFirstRender !== undefined ])
    return jsx
})








let createObservable = resource => {
    const agent = new EventEmitter;
    const monitor = node => {
        if (typeof node.on === 'function') node.on('Δ.change', () => agent.emit(`change`))
        else if(isPlain(node)) each(node, (key, value) => {
            Object.defineProperty(node, key, {
                enumerable: true,
                get: () => value,
                set: newValue => {
                    value = newValue
                    agent.emit(`change`)
                }
            })
        })
    }
    crawl(resource, monitor)
    return agent.on('change')
}
const primativeTypes = ['String', 'Boolean', 'Number', 'Date', 'Function']
const isPlain = value => value && typeof value === 'object' && !primativeTypes.includes(value.constructor.name) && typeof value.on !== 'function'
const crawl = (obj, callback) => {
    callback(obj)
    if (isPlain(obj)) {
        for (let key in obj) {
            callback(obj[key])
            let value = obj[key]
            crawl(value, callback)
        }
    }
}