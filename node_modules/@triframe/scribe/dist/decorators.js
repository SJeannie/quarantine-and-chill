"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.stream = exports.include = exports.validate = exports.session = exports.shared = exports.readonlyUnless = exports.hiddenUnless = exports.readonly = exports.hidden = exports.belongsTo = exports.hasOne = exports.hasMany = exports.temp = exports.derive = exports.pk = exports.serial = exports.json = exports.list = exports.circle = exports.polygon = exports.path = exports.lseg = exports.line = exports.point = exports.time = exports.date = exports.timestamptz = exports.timestamp = exports.boolean = exports.integer = exports.float = exports.numeric = exports.text = exports.string = undefined;

var _core = require("@triframe/core");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

//  ---------------------- DATATYPES ----------------------
const string = exports.string = createPropertyDecorator(({
  decoratorArgs
}) => ({
  datatype: 'varchar',
  constraints: decoratorArgs[1] || {}
}));
const text = exports.text = createPropertyDecorator(({
  decoratorArgs
}) => ({
  datatype: 'text',
  constraints: decoratorArgs[1] || {}
}));
const numeric = exports.numeric = createPropertyDecorator(({
  decoratorArgs
}) => ({
  datatype: 'numeric',
  constraints: decoratorArgs[1] || {}
}));
const float = exports.float = createPropertyDecorator(({
  decoratorArgs
}) => ({
  datatype: 'float8',
  constraints: decoratorArgs[1] || {}
}));
const integer = exports.integer = createPropertyDecorator(({
  decoratorArgs
}) => ({
  datatype: 'int4',
  constraints: decoratorArgs[1] || {}
}));
const boolean = exports.boolean = createPropertyDecorator(({
  decoratorArgs
}) => ({
  datatype: 'bool',
  constraints: decoratorArgs[1] || {}
}));
const timestamp = exports.timestamp = createPropertyDecorator(({
  decoratorArgs
}) => ({
  datatype: 'timestamptz',
  constraints: decoratorArgs[1] || {},
  sqlEncode: value => value instanceof _core.DateTime ? value.toJSDate() : value,
  sqlDecode: value => value instanceof Date ? _core.DateTime.fromJSDate(value) : _core.DateTime.fromISO(value)
}));
const timestamptz = exports.timestamptz = createPropertyDecorator(({
  decoratorArgs
}) => ({
  datatype: 'timestamptz',
  constraints: decoratorArgs[1] || {}
}));
const date = exports.date = createPropertyDecorator(({
  decoratorArgs
}) => ({
  datatype: 'date',
  constraints: decoratorArgs[1] || {}
}));
const time = exports.time = createPropertyDecorator(({
  decoratorArgs
}) => ({
  datatype: 'time',
  constraints: decoratorArgs[1] || {}
}));
const point = exports.point = createPropertyDecorator(({
  decoratorArgs
}) => ({
  datatype: 'point',
  constraints: decoratorArgs[1] || {}
}));
const line = exports.line = createPropertyDecorator(({
  decoratorArgs
}) => ({
  datatype: 'line',
  constraints: decoratorArgs[1] || {}
}));
const lseg = exports.lseg = createPropertyDecorator(({
  decoratorArgs
}) => ({
  datatype: 'lseg',
  constraints: decoratorArgs[1] || {}
}));
const path = exports.path = createPropertyDecorator(({
  decoratorArgs
}) => ({
  datatype: 'path',
  constraints: decoratorArgs[1] || {}
}));
const polygon = exports.polygon = createPropertyDecorator(({
  decoratorArgs
}) => ({
  datatype: 'polygon',
  constraints: decoratorArgs[1] || {}
}));
const circle = exports.circle = createPropertyDecorator(({
  decoratorArgs
}) => ({
  datatype: 'circle',
  constraints: decoratorArgs[1] || {}
}));
const list = exports.list = createPropertyDecorator(({
  decoratorArgs
}) => ({
  datatype: 'json',
  constraints: decoratorArgs[1] || {},
  sqlEncode: value => JSON.stringify(value),
  sqlDecode: value => {
    try {
      return JSON.parse(value);
    } catch (err) {
      return value;
    }
  }
}));
const json = exports.json = createPropertyDecorator(({
  decoratorArgs
}) => ({
  datatype: 'json',
  constraints: decoratorArgs[1] || {},
  sqlEncode: value => JSON.stringify(value),
  sqlDecode: value => {
    try {
      return JSON.parse(value);
    } catch (err) {
      return value;
    }
  }
}));
const serial = exports.serial = createPropertyDecorator(({
  decoratorArgs
}) => ({
  datatype: 'SERIAL',
  constraints: decoratorArgs[0] || {}
}));
const pk = exports.pk = serial({
  primaryKey: true
});
const derive = exports.derive = createDecorator(({
  decoratorArgs: [opts],
  target,
  key,
  fieldValue
}) => {
  if (!opts.sql && !opts.code) throw Error(`Must provide either 'sql' or 'code' option when defining derived field (${key})`);
  Object.defineProperty(target, key, createDocumentProperty(key));
  return {
    isShared: true,
    type: opts.sql ? 'sql-derived' : 'code-derived',
    definition: opts.sql || opts.code,
    defaultValue: fieldValue
  };
});
const temp = exports.temp = createPropertyDecorator(({
  decoratorArgs: [opts],
  target,
  key,
  fieldValue
}) => {
  Object.defineProperty(target, key, createDocumentProperty(key, true));
  return {
    isShared: true,
    type: 'temporary',
    defaultValue: fieldValue
  };
});
const hasMany = exports.hasMany = createPropertyDecorator(({
  decoratorArgs: [options = {}],
  target,
  key,
  fieldValue
}) => {
  Object.defineProperty(target, key, createDocumentProperty(key));
  return {
    isShared: true,
    type: 'relationship',
    joinType: 'hasMany',
    options,
    defaultValue: fieldValue
  };
});
const hasOne = exports.hasOne = createPropertyDecorator(({
  decoratorArgs: [options = {}],
  target,
  key,
  fieldValue
}) => {
  Object.defineProperty(target, key, createDocumentProperty(key));
  return {
    isShared: true,
    type: 'relationship',
    joinType: 'hasOne',
    options,
    defaultValue: fieldValue
  };
});
const belongsTo = exports.belongsTo = createPropertyDecorator(({
  decoratorArgs: [options = {}],
  target,
  key,
  fieldValue
}) => {
  let foreignKey = (0, _core.toCamelCase)((0, _core.toForeignKeyName)(key));
  (0, _core.saveMetadata)(target, foreignKey, {
    type: 'persisted',
    datatype: 'int4',
    isShared: true
  });
  Object.defineProperty(target, key, createDocumentProperty(key));
  Object.defineProperty(target, foreignKey, createDocumentProperty(foreignKey));
  return {
    isShared: true,
    type: 'relationship',
    joinType: 'belongsTo',
    options,
    defaultValue: fieldValue
  };
}); //  --------------------- ACCESS LEVELS --------------------
// arbiter?

const hidden = exports.hidden = createDecorator(({
  decoratorArgs,
  fieldValue
}) => ({
  readAccessTest: () => false
}));
const readonly = exports.readonly = createDecorator(({
  decoratorArgs,
  fieldValue
}) => ({
  writeAccessTest: () => false
}));
const hiddenUnless = exports.hiddenUnless = createDecorator(({
  decoratorArgs,
  fieldValue
}) => ({
  readAccessTest: decoratorArgs[0]
}));
const readonlyUnless = exports.readonlyUnless = createDecorator(({
  decoratorArgs,
  fieldValue
}) => ({
  writeAccessTest: decoratorArgs[0]
})); //  ---------------------- MISC ----------------------

const shared = exports.shared = createDecorator(({
  decoratorArgs,
  fieldValue
}) => ({
  isShared: true
}));
const session = exports.session = createDecorator(({
  decoratorArgs,
  fieldValue
}) => ({
  usesSession: true
})); // core?

const validate = exports.validate = createDecorator(({
  decoratorArgs,
  target,
  key,
  fieldValue
}) => {
  decoratorArgs.forEach(validator => target.validation.addHandler(key, validator));
  return {
    validators: decoratorArgs
  };
});

const include = exports.include = (...models) => decorated => {
  register(target => {
    let Class = typeof target === 'function' ? target : target.constructor;
    let prototype = typeof target === 'function' ? target.prototype : target;
    (0, _core.each)(models, (key, Model) => {
      // Copy Static
      (0, _core.each)(Object.getOwnPropertyDescriptors(Model), (key, descriptor) => {
        if (key == 'name' || key == 'prototype' || key == 'length') return;
        let metadata = (0, _core.getMetadata)(Model, key);
        if (!isEmpty(metadata)) (0, _core.saveMetadata)(Class, key, metadata);
        Object.defineProperty(Class, key, descriptor);
      }); // Copy Prototype

      (0, _core.each)(Object.getOwnPropertyDescriptors(Model.prototype), (key, descriptor) => {
        if (key === 'constructor' || key === 'onConstruct' || key === '[[validation]]') return;
        let metadata = (0, _core.getMetadata)({
          __proto__: {
            constructor: Model
          }
        }, key);
        if (!isEmpty(metadata)) (0, _core.saveMetadata)(prototype, key, metadata);
        Object.defineProperty(prototype, key, descriptor);
      });

      if (Model.prototype['[[validation]]']) {
        if (prototype['[[validation]]']) prototype['[[validation]]'].handlers = _objectSpread(_objectSpread({}, prototype['[[validation]]'].handlers), Model.prototype['[[validation]]'].handlers);else prototype['[[validation]]'] = Model.prototype['[[validation]]'];
      }
    });
  })(decorated);
  initialize(object => {
    (0, _core.each)(models, (key, Model) => {
      if (Model.prototype.onConstruct) Model.prototype.onConstruct.call(object);
    });
  })(decorated);
};

function createStream(method, prependEmit = false) {
  const process = function (emit, ...args) {
    if (prependEmit) args.unshift(emit);
    return method.call(this, ...args);
  };

  return function (...args) {
    return new _core.Pipe([this, process], ...args);
  };
}

const stream = exports.stream = (decorated, prependEmit = false) => {
  if (typeof decorated === 'object') {
    let original;
    register((target, key) => {
      (0, _core.saveMetadata)(target, key, {
        isStream: true,
        prependEmit,
        original
      });
    })(decorated);
    wrap(method => {
      original = method;
      return createStream(method, prependEmit);
    })(decorated);
    return decorated;
  }

  if (typeof decorated === 'function') {
    return createStream(decorated, prependEmit);
  }

  if (typeof decorated === 'boolean') {
    return x => stream(x, decorated);
  }
}; // TODO: VALIDATION DECORATOR


function createPropertyDecorator(define) {
  const decorator = function (decorated, decoratorArgs = []) {
    decorated = register((target, key, fieldValue) => {
      (0, _core.saveMetadata)(target, key, _objectSpread({
        isShared: true,
        type: 'persisted',
        defaultValue: fieldValue
      }, define({
        decoratorArgs,
        target,
        key,
        fieldValue
      })));
    })(decorated);
    delete decorated.initializer;
    delete decorated.descriptor.value;
    delete decorated.descriptor.writable;
    return _objectSpread(_objectSpread({}, decorated), {}, {
      kind: 'method',
      placement: 'prototype',
      descriptor: _objectSpread(_objectSpread({}, decorated.descriptor), createDocumentProperty(decorated.key))
    }); // initialize((target, key, value) => { })(decorated)
  };

  return function (...args) {
    if (args[0] && args[0].descriptor && args[0].kind) return decorator(args[0]);
    return decorated => decorator(decorated, args);
  };
}

function createDecorator(define) {
  const decorator = function (decorated, decoratorArgs = []) {
    decorated = register((target, key, fieldValue, isMethod) => (0, _core.saveMetadata)(target, key, _objectSpread({}, define({
      decoratorArgs,
      target,
      key,
      fieldValue,
      isMethod
    }))))(decorated); // delete decorated.initializer
    // delete decorated.descriptor.value
    // delete decorated.descriptor.writable

    if (decorated.kind == 'field' && decorated.initializer === undefined) {
      decorated.initializer = function () {
        return this[decorated.key];
      };
    }

    return decorated;
  };

  return function (...args) {
    if (args[0] && args[0].descriptor && args[0].kind) return decorator(args[0]);
    return decorated => decorator(decorated, args);
  };
}

function createDocumentProperty(key, temp = false) {
  return {
    enumerable: true,
    get: new Function(`
            if(this['[[attributes]]'].id && this['[[attributes]]'].${key} === undefined) throw Error('Tried to reference "${key}", which was not included when resource was queried, or has not been defined yet')
            return this['[[attributes]]'].${key}
        `),
    set: new Function('value', `
            this['[[attributes]]'].${key} = value
            let patch = {
                ${temp ? 'isTemporary: true,' : ''}
                op: 'replace',
                path: '/${key}',
                value
            }
            this['[[patches]]'].push(patch)
            this.emit('Î”.change', [ patch ])
        `)
  };
}

function register(callback) {
  return function (decorated) {
    let previous = decorated.finisher;
    let {
      initializer
    } = decorated;

    decorated.finisher = Class => {
      var _decorated$descriptor, _decorated$descriptor2;

      if (typeof previous == 'function') previous(Class);
      let value;

      switch (decorated.placement) {
        case 'class':
          callback(Class);
          break;

        case 'static':
          value = decorated.kind === 'field' && typeof initializer === 'function' ? initializer() : (_decorated$descriptor = decorated.descriptor) === null || _decorated$descriptor === void 0 ? void 0 : _decorated$descriptor.value;
          callback(Class, decorated.key, value);
          break;

        default:
          value = decorated.kind === 'field' && typeof initializer === 'function' ? initializer() : (_decorated$descriptor2 = decorated.descriptor) === null || _decorated$descriptor2 === void 0 ? void 0 : _decorated$descriptor2.value;
          callback(Class.prototype, decorated.key, value, decorated.kind === 'method');
      }
    };

    return decorated;
  };
}

function wrap(callback) {
  return function (decorated) {
    let original;

    switch (decorated.kind) {
      case 'field':
        original = typeof decorated.initializer === 'function' ? decorated.initializer : () => null;

        decorated.initializer = () => function (...args) {
          callback(() => original(...args));
        };

        break;

      case 'method':
        original = decorated.descriptor.value;
        decorated.descriptor.value = callback(original);
        break;
    }

    return decorated;
  };
}

function initialize(callback) {
  return function (decorated) {
    let temp = Symbol();
    decorated.extras = [{
      kind: 'field',
      placement: 'own',
      key: temp,
      descriptor: {},

      initializer() {
        delete this[temp]; // let value = typeof decorated.initializer === 'function' ? decorated.initializer() : undefined

        callback(this);
      }

    }];
  };
}

const isEmpty = x => Object.keys(x).length === 0;
//# sourceMappingURL=decorators.js.map