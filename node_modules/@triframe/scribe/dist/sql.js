"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sql = exports.any = exports.all = exports.reduce = exports.pairs = exports.values = exports.keys = exports.isLiteral = exports.literal = undefined;

var _core = require("@triframe/core");

var _database = require("./database");

var _parseTriQL = require("./parseTriQL");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const literal = exports.literal = x => ({
  isLiteral: true,
  value: x
});

const isLiteral = exports.isLiteral = x => x && x.isLiteral;

const literalValue = (x, escape) => typeof x.value === 'function' ? x.value(escape) : x.value;

const keys = exports.keys = x => {
  return {
    join: sep => literal(Object.keys(x).map(_core.toUnderscored).join(sep))
  };
};

const values = exports.values = x => {
  return {
    join: sep => literal(escape => Object.values(x).map(escape).join(sep))
  };
};

const pairs = exports.pairs = (x, seperator = value => value === null ? ' IS NULL' : ` = ${escape(value)}`) => {
  let seperate;
  if (typeof seperator !== 'function') seperate = value => ` ${seperator} ${escape(value)}`;else seperate = seperator;
  return {
    join: sep => literal(escape => Object.keys(x).map(key => `${(0, _core.toUnderscored)(key)}${seperate(x[key])}`).join(sep))
  };
};

const createReducer = seperator => (x, reducer) => literal(escape => {
  let result;
  (0, _core.each)(x, (key, value) => result = result === undefined ? reducer((0, _core.toUnderscored)(key), {
    toString: () => escape(value)
  }, {
    rawValue: value,
    escape
  }) : `${result}${seperator}${reducer((0, _core.toUnderscored)(key), {
    toString: () => escape(value)
  }, {
    rawValue: value,
    escape
  })}`);
  return result;
});

const reduce = exports.reduce = createReducer(', ');
const all = exports.all = createReducer(' AND ');
const any = exports.any = createReducer(' OR ');
let models;
let defaultOptions = {
  disableLogging: false
};

const sql = exports.sql = (...args) => {
  if (Array.isArray(args[0])) {
    return runQuery(defaultOptions, ...args);
  } else {
    let options = args[0];
    return (...args) => runQuery(options, ...args);
  }
};

const runQuery = (options, queryFragments, ...variables) => {
  let escaped = [];

  let escape = x => {
    escaped.push(x);
    return `$${escaped.length}`;
  };

  let triQL = queryFragments.reduce((triQL, fragment, index) => index === 0 ? `${fragment}` : isLiteral(variables[index - 1]) ? `${triQL}${literalValue(variables[index - 1], escape)}${fragment}` : `${triQL}${escape(variables[index - 1])}${fragment}`, '');
  const {
    query,
    events
  } = (0, _parseTriQL.parseTriQL)(triQL);
  return new _core.Pipe(queryProcess, options, query, escaped, events);
};

function* queryProcess(emit, options, triQL, escaped, events) {
  if (!options.disableLogging) console.log(triQL, escaped, events.map(({
    Class,
    event
  }) => `${Class.name}.${event}`));

  for (let {
    Class,
    event
  } of events) yield Class.nowAndOn(event);

  const response = yield _database.database.query(triQL, escaped);
  if (!models) models = (0, _core.index)(_core.metadata, (_, {
    className
  }) => className, (_, {
    Class
  }) => Class);
  let promisedResolutions = [];
  let result = (0, _core.deepMap)(response.rows, value => {
    if (value && value.__class__) {
      if (value.id === null) return null;
      let Model = models[value.__class__];
      let tempInstance = new Model();
      let tempMetadata = (0, _core.filter)(_core.metadata, (namespace, record) => namespace.startsWith(`${Model.name}#`) && record.type === 'temporary');
      let tempProperties = (0, _core.index)(tempMetadata, (_, record) => record.key, (_, record) => record.defaultValue);

      let camelCasedKeys = key => (0, _core.toCamelCase)(key);

      let jsDefinitionResolutions = [];

      let decodedValues = (key, value) => {
        const {
          sqlDecode,
          type,
          definition,
          defaultValue
        } = (0, _core.getMetadata)(tempInstance, (0, _core.toCamelCase)(key));

        if (sqlDecode) {
          return sqlDecode(value);
        } else if (type === 'code-derived') {
          jsDefinitionResolutions.push(instance => instance['[[attributes]]'][(0, _core.toCamelCase)(key)] = definition(instance) || defaultValue);
        } else {
          return value;
        }
      };

      delete value.__class__;
      let instance = new Model(_objectSpread(_objectSpread({}, tempProperties), (0, _core.index)(value, camelCasedKeys, decodedValues)));
      jsDefinitionResolutions.forEach(resolveDefinition => promisedResolutions.push(resolveDefinition(instance)));
      return instance;
    }

    if (Array.isArray(value) && value.every(element => typeof element === 'object' && (element == null || typeof element.id !== 'undefined'))) {
      let result = [];
      let alreadyAdded = {};
      value.forEach(value => {
        if (value !== null && value.id !== null && !alreadyAdded[value.id]) {
          alreadyAdded[value.id] = true;
          result.push(value);
        }
      });
      return result;
    }

    return value;
  });
  yield Promise.all(promisedResolutions);
  return result;
}
//# sourceMappingURL=sql.js.map