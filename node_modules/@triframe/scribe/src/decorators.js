import { saveMetadata, getMetadata, toForeignKeyName, each, metadata, index, toCamelCase, Pipe, DateTime } from '@triframe/core'


//  ---------------------- DATATYPES ----------------------

export const string = createPropertyDecorator(({ decoratorArgs }) => ({
    datatype: 'varchar',
    constraints: decoratorArgs[1] || {}
}))

export const text = createPropertyDecorator(({ decoratorArgs }) => ({
    datatype: 'text',
    constraints: decoratorArgs[1] || {}
}))

export const numeric = createPropertyDecorator(({ decoratorArgs }) => ({
    datatype: 'numeric',
    constraints: decoratorArgs[1] || {}
}))

export const float = createPropertyDecorator(({ decoratorArgs }) => ({
    datatype: 'float8',
    constraints: decoratorArgs[1] || {}
}))

export const integer = createPropertyDecorator(({ decoratorArgs }) => ({
    datatype: 'int4',
    constraints: decoratorArgs[1] || {}
}))

export const boolean = createPropertyDecorator(({ decoratorArgs }) => ({
    datatype: 'bool',
    constraints: decoratorArgs[1] || {}
}))

export const timestamp = createPropertyDecorator(({ decoratorArgs }) => ({
    datatype: 'timestamptz',
    constraints: decoratorArgs[1] || {},
    sqlEncode: value => value instanceof DateTime ? value.toJSDate() : value,
    sqlDecode: value => value instanceof Date ? DateTime.fromJSDate(value) : DateTime.fromISO(value)
}))

export const timestamptz = createPropertyDecorator(({ decoratorArgs }) => ({
    datatype: 'timestamptz',
    constraints: decoratorArgs[1] || {}
}))

export const date = createPropertyDecorator(({ decoratorArgs }) => ({
    datatype: 'date',
    constraints: decoratorArgs[1] || {}
}))

export const time = createPropertyDecorator(({ decoratorArgs }) => ({
    datatype: 'time',
    constraints: decoratorArgs[1] || {}
}))

export const point = createPropertyDecorator(({ decoratorArgs }) => ({
    datatype: 'point',
    constraints: decoratorArgs[1] || {}
}))

export const line = createPropertyDecorator(({ decoratorArgs }) => ({
    datatype: 'line',
    constraints: decoratorArgs[1] || {}
}))

export const lseg = createPropertyDecorator(({ decoratorArgs }) => ({
    datatype: 'lseg',
    constraints: decoratorArgs[1] || {}
}))

export const path = createPropertyDecorator(({ decoratorArgs }) => ({
    datatype: 'path',
    constraints: decoratorArgs[1] || {}
}))

export const polygon = createPropertyDecorator(({ decoratorArgs }) => ({
    datatype: 'polygon',
    constraints: decoratorArgs[1] || {}
}))

export const circle = createPropertyDecorator(({ decoratorArgs }) => ({
    datatype: 'circle',
    constraints: decoratorArgs[1] || {}
}))

export const list = createPropertyDecorator(({ decoratorArgs }) => ({
    datatype: 'json',
    constraints: decoratorArgs[1] || {},
    sqlEncode: value => JSON.stringify(value),
    sqlDecode: value => {
        try {
            return JSON.parse(value)
        } catch (err) {
            return value;
        }
    }
}))

export const json = createPropertyDecorator(({ decoratorArgs }) => ({
    datatype: 'json',
    constraints: decoratorArgs[1] || {},
    sqlEncode: value => JSON.stringify(value),
    sqlDecode: value => {
        try {
            return JSON.parse(value)
        } catch (err) {
            return value;
        }
    }
}))

export const serial = createPropertyDecorator(({ decoratorArgs }) => ({
    datatype: 'SERIAL',
    constraints: decoratorArgs[0] || {}
}))

export const pk = serial({ primaryKey: true })

export const derive = createDecorator(({ decoratorArgs: [opts], target, key, fieldValue }) => {
    if (!opts.sql && !opts.code) throw Error(`Must provide either 'sql' or 'code' option when defining derived field (${key})`)
    Object.defineProperty(target, key, createDocumentProperty(key))
    return {
        isShared: true,
        type: opts.sql ? 'sql-derived' : 'code-derived',
        definition: opts.sql || opts.code,
        defaultValue: fieldValue
    }
})

export const temp = createPropertyDecorator(({ decoratorArgs: [opts], target, key, fieldValue }) => {
    Object.defineProperty(target, key, createDocumentProperty(key, true))
    return {
        isShared: true,
        type: 'temporary',
        defaultValue: fieldValue
    }
})

export const hasMany = createPropertyDecorator(({ decoratorArgs: [options = {}], target, key, fieldValue }) => {
    Object.defineProperty(target, key, createDocumentProperty(key))
    return {
        isShared: true,
        type: 'relationship',
        joinType: 'hasMany',
        options,
        defaultValue: fieldValue
    }
})

export const hasOne = createPropertyDecorator(({ decoratorArgs: [options = {}], target, key, fieldValue }) => {
    Object.defineProperty(target, key, createDocumentProperty(key))
    return {
        isShared: true,
        type: 'relationship',
        joinType: 'hasOne',
        options,
        defaultValue: fieldValue
    }
})

export const belongsTo = createPropertyDecorator(({ decoratorArgs: [options = {}], target, key, fieldValue }) => {
    let foreignKey = toCamelCase(toForeignKeyName(key))
    saveMetadata(target, foreignKey, {
        type: 'persisted',
        datatype: 'int4',
        isShared: true
    })
    Object.defineProperty(target, key, createDocumentProperty(key))
    Object.defineProperty(target, foreignKey, createDocumentProperty(foreignKey))
    return {
        isShared: true,
        type: 'relationship',
        joinType: 'belongsTo',
        options,
        defaultValue: fieldValue
    }
})

//  --------------------- ACCESS LEVELS --------------------

// arbiter?

export const hidden = createDecorator(({ decoratorArgs, fieldValue }) => ({
    readAccessTest: () => false
}))

export const readonly = createDecorator(({ decoratorArgs, fieldValue }) => ({
    writeAccessTest: () => false
}))

export const hiddenUnless = createDecorator(({ decoratorArgs, fieldValue }) => ({
    readAccessTest: decoratorArgs[0]
}))

export const readonlyUnless = createDecorator(({ decoratorArgs, fieldValue }) => ({
    writeAccessTest: decoratorArgs[0]
}))



//  ---------------------- MISC ----------------------


export const shared = createDecorator(({ decoratorArgs, fieldValue }) => ({
    isShared: true
}))


export const session = createDecorator(({ decoratorArgs, fieldValue }) => ({
    usesSession: true
}))


// core?

export const validate = createDecorator(({ decoratorArgs, target, key, fieldValue }) => {
    decoratorArgs.forEach(validator => target.validation.addHandler(key, validator))
    return {
        validators: decoratorArgs
    }
})

export const include = (...models) => decorated => {

    register((target) => {

        let Class = typeof target === 'function' ? target : target.constructor
        let prototype = typeof target === 'function' ? target.prototype : target


        each(models, (key, Model) => {


            // Copy Static
            each(Object.getOwnPropertyDescriptors(Model), (key, descriptor) => {
                if (key == 'name' || key == 'prototype' || key == 'length') return
                let metadata = getMetadata(Model, key)
                if (!isEmpty(metadata)) saveMetadata(Class, key, metadata)
                Object.defineProperty(Class, key, descriptor)
            })

            // Copy Prototype
            each(Object.getOwnPropertyDescriptors(Model.prototype), (key, descriptor) => {
                if (key === 'constructor' || key === 'onConstruct' || key === '[[validation]]') return
                let metadata = getMetadata({ __proto__: { constructor: Model } }, key)
                if (!isEmpty(metadata)) saveMetadata(prototype, key, metadata)
                Object.defineProperty(prototype, key, descriptor)
            })

            if (Model.prototype['[[validation]]']) {
                if (prototype['[[validation]]']) prototype['[[validation]]'].handlers = { ...prototype['[[validation]]'].handlers, ...Model.prototype['[[validation]]'].handlers }
                else prototype['[[validation]]'] = Model.prototype['[[validation]]']
            }

        })

    })(decorated)


    initialize((object) => {
        each(models, (key, Model) => {
            if (Model.prototype.onConstruct) Model.prototype.onConstruct.call(object)
        })
    })(decorated)
}

function createStream(method, prependEmit = false) {
    const process = function (emit, ...args) {
        if (prependEmit) args.unshift(emit)
        return method.call(this, ...args)
    }
    return function (...args) {
        return new Pipe([this, process], ...args)
    }
}

export const stream = (decorated, prependEmit = false) => {
    if (typeof decorated === 'object') {
        let original;
        register((target, key) => {
            saveMetadata(target, key, {
                isStream: true,
                prependEmit,
                original
            })
        })(decorated)
        wrap(method => {
            original = method
            return createStream(method, prependEmit)
        })(decorated)
        return decorated
    }
    if (typeof decorated === 'function') {
        return createStream(decorated, prependEmit)
    }
    if (typeof decorated === 'boolean') {
        return x => stream(x, decorated)
    }
}

// TODO: VALIDATION DECORATOR


function createPropertyDecorator(define) {

    const decorator = function (decorated, decoratorArgs = []) {
        decorated = register((target, key, fieldValue) => {
            saveMetadata(target, key, {
                isShared: true,
                type: 'persisted',
                defaultValue: fieldValue,
                ...define({ decoratorArgs, target, key, fieldValue })
            })
        })(decorated)
        delete decorated.initializer
        delete decorated.descriptor.value
        delete decorated.descriptor.writable
        return {
            ...decorated,
            kind: 'method',
            placement: 'prototype',
            descriptor: {
                ...decorated.descriptor,
                ...createDocumentProperty(decorated.key)
            }
        } // initialize((target, key, value) => { })(decorated)
    }

    return function (...args) {
        if (args[0] && args[0].descriptor && args[0].kind) return decorator(args[0])
        return decorated => decorator(decorated, args)
    }
}

function createDecorator(define) {

    const decorator = function (decorated, decoratorArgs = []) {
        decorated = register((target, key, fieldValue, isMethod) =>
            saveMetadata(target, key, {
                ...define({ decoratorArgs, target, key, fieldValue, isMethod })
            })
        )(decorated)
        // delete decorated.initializer
        // delete decorated.descriptor.value
        // delete decorated.descriptor.writable

        if(decorated.kind == 'field' && decorated.initializer === undefined){
            decorated.initializer = function() {
                return this[decorated.key]
            }
        }

        return decorated
    }

    return function (...args) {
        if (args[0] && args[0].descriptor && args[0].kind) return decorator(args[0])
        return decorated => decorator(decorated, args)
    }
}

function createDocumentProperty(key, temp = false) {
    return {
        enumerable: true,
        get: new Function(`
            if(this['[[attributes]]'].id && this['[[attributes]]'].${key} === undefined) throw Error('Tried to reference "${key}", which was not included when resource was queried, or has not been defined yet')
            return this['[[attributes]]'].${key}
        `),
        set: new Function('value', `
            this['[[attributes]]'].${key} = value
            let patch = {
                ${temp ? 'isTemporary: true,': ''}
                op: 'replace',
                path: '/${key}',
                value
            }
            this['[[patches]]'].push(patch)
            this.emit('Δ.change', [ patch ])
        `)
    }
}

function register(callback) {
    return function (decorated) {
        let previous = decorated.finisher
        let { initializer } = decorated
        decorated.finisher = Class => {
            if (typeof previous == 'function') previous(Class)
            let value;
            switch (decorated.placement) {
                case 'class':
                    callback(Class)
                    break;
                case 'static':
                    value = decorated.kind === 'field' && typeof initializer === 'function' ? initializer() : decorated.descriptor?.value
                    callback(Class, decorated.key, value)
                    break;
                default:
                    value = decorated.kind === 'field' && typeof initializer === 'function' ? initializer() : decorated.descriptor?.value
                    callback(Class.prototype, decorated.key, value, decorated.kind === 'method')

            }
        }
        return decorated
    }
}

function wrap(callback) {
    return function (decorated) {
        let original;
        switch (decorated.kind) {
            case 'field':
                original = typeof decorated.initializer === 'function' ? decorated.initializer : () => null
                decorated.initializer = () => function (...args) {
                    callback(() => original(...args))
                }
                break;
            case 'method':
                original = decorated.descriptor.value
                decorated.descriptor.value = callback(original)
                break;
        }
        return decorated
    }
}

function initialize(callback) {
    return function (decorated) {
        let temp = Symbol()
        decorated.extras = [{
            kind: 'field',
            placement: 'own',
            key: temp,
            descriptor: {},
            initializer() {
                delete this[temp]
                // let value = typeof decorated.initializer === 'function' ? decorated.initializer() : undefined
                callback(this)
            }
        }]
    }
}

const isEmpty = x => Object.keys(x).length === 0