{"version":3,"sources":["../../../../../src/paper/components/TextInput/Label/InputLabel.js"],"names":["InputLabel","props","parentState","labelBackground","labelProps","label","error","onLayoutAnimatedText","hasActiveOutline","activeColor","placeholderStyle","baseLabelTranslateX","baseLabelTranslateY","font","fontSize","fontWeight","placeholderOpacity","wiggleOffsetX","labelScale","topPosition","paddingOffset","placeholderColor","errorColor","labelTranslationX","transform","translateX","labeled","interpolate","inputRange","outputRange","labelStyle","value","translateY","scale","StyleSheet","absoluteFill","opacity","focused","labelLayout","measured","top","color"],"mappings":"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","sourcesContent":["import React from 'react';\r\nimport { Animated, StyleSheet } from 'react-native';\r\nimport AnimatedText from '../../Typography/AnimatedText';\r\nconst InputLabel = (props) => {\r\n    const { parentState, labelBackground } = props;\r\n    const { label, error, onLayoutAnimatedText, hasActiveOutline, activeColor, placeholderStyle, baseLabelTranslateX, baseLabelTranslateY, font, fontSize, fontWeight, placeholderOpacity, wiggleOffsetX, labelScale, topPosition, paddingOffset, placeholderColor, errorColor, } = props.labelProps;\r\n    const labelTranslationX = {\r\n        transform: [\r\n            {\r\n                // Offset label scale since RN doesn't support transform origin\r\n                translateX: parentState.labeled.interpolate({\r\n                    inputRange: [0, 1],\r\n                    outputRange: [baseLabelTranslateX, 0],\r\n                }),\r\n            },\r\n        ],\r\n    };\r\n    const labelStyle = {\r\n        ...font,\r\n        fontSize,\r\n        fontWeight,\r\n        transform: [\r\n            {\r\n                // Wiggle the label when there's an error\r\n                translateX: parentState.error.interpolate({\r\n                    inputRange: [0, 0.5, 1],\r\n                    outputRange: [0, parentState.value && error ? wiggleOffsetX : 0, 0],\r\n                }),\r\n            },\r\n            {\r\n                // Move label to top\r\n                translateY: parentState.labeled.interpolate({\r\n                    inputRange: [0, 1],\r\n                    outputRange: [baseLabelTranslateY, 0],\r\n                }),\r\n            },\r\n            {\r\n                // Make label smaller\r\n                scale: parentState.labeled.interpolate({\r\n                    inputRange: [0, 1],\r\n                    outputRange: [labelScale, 1],\r\n                }),\r\n            },\r\n        ],\r\n    };\r\n    return label ? (\r\n    // Position colored placeholder and gray placeholder on top of each other and crossfade them\r\n    // This gives the effect of animating the color, but allows us to use native driver\r\n    <Animated.View pointerEvents=\"none\" style={[\r\n        StyleSheet.absoluteFill,\r\n        {\r\n            opacity: \r\n            // Hide the label in minimized state until we measure it's width\r\n            parentState.value || parentState.focused\r\n                ? parentState.labelLayout.measured\r\n                    ? 1\r\n                    : 0\r\n                : 1,\r\n        },\r\n        labelTranslationX,\r\n    ]}>\r\n      {labelBackground?.({\r\n        parentState,\r\n        labelStyle,\r\n        labelProps: props.labelProps,\r\n    })}\r\n      <AnimatedText onLayout={onLayoutAnimatedText} style={[\r\n        placeholderStyle,\r\n        {\r\n            top: topPosition,\r\n        },\r\n        labelStyle,\r\n        paddingOffset || {},\r\n        {\r\n            color: activeColor,\r\n            opacity: parentState.labeled.interpolate({\r\n                inputRange: [0, 1],\r\n                outputRange: [hasActiveOutline ? 1 : 0, 0],\r\n            }),\r\n        },\r\n    ]} numberOfLines={1}>\r\n        {label}\r\n      </AnimatedText>\r\n      <AnimatedText style={[\r\n        placeholderStyle,\r\n        {\r\n            top: topPosition,\r\n        },\r\n        labelStyle,\r\n        paddingOffset,\r\n        {\r\n            color: error && errorColor ? errorColor : placeholderColor,\r\n            opacity: placeholderOpacity,\r\n        },\r\n    ]} numberOfLines={1}>\r\n        {label}\r\n      </AnimatedText>\r\n    </Animated.View>) : null;\r\n};\r\nexport default InputLabel;\r\n"],"file":"InputLabel.js"}