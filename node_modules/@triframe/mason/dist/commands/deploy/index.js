"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = require("../../utils");

var _adapters = require("../../adapters");

var _createRelease = require("./createRelease");

const sleep = time => new Promise(resolve => setTimeout(resolve, time));

const buildCommands = {
  'web': 'npx react-scripts build',
  'native': 'expo build:web'
};
const buildDestinations = {
  'web': 'build',
  'native': 'web-build'
};

exports.default = async (name, version = undefined) => {
  let {
    deployments,
    platform
  } = await (0, _utils.getState)();
  let deployment = deployments[name];
  if (deployment === undefined) return (0, _utils.print)(`No such deployment '${name}'; you could add it:
    npx triframe deployment add ${name}    
`);
  let adapter = _adapters.Adapters[deployment.target];
  await adapter.dependencyCheck();
  let repo = new _utils.Repo();
  let initialBranch = await repo.getCurrentBranch();

  if (!(await repo.isCommitted())) {
    return (0, _utils.print)('Your repo has uncommited changes; please commit before attempting to deploy');
  }

  (0, _utils.print)('Building Backend...');
  await (0, _utils.exec)(`npx babel ./src --out-dir=./dist --config-file ${_utils.path.resolve(__dirname, './api.babel.config.js')}`, {
    printOut: true
  });
  (0, _utils.print)('Building Frontend...');
  await (0, _utils.exec)(`${buildCommands[platform]}`, {
    printOut: true
  });
  await _utils.fs.copy(buildDestinations[platform], './dist/public');
  await repo.checkout(`${name}`);
  await _utils.fs.copy('./dist', '.');

  try {
    await repo.checkout('master', './package.json');
    await repo.checkout('master', './package-lock.json');

    try {
      await repo.checkout('master', '.npmrc');
    } catch (err) {} // no op
    // await sleep(1000)


    const packagePath = _utils.path.join(process.cwd(), 'package.json');

    const config = require(packagePath);

    config.engines = {
      "node": process.version.slice(1)
    };
    config.scripts = {
      "start": "node ./Api.js"
    };
    await _utils.fs.writeFile(packagePath, JSON.stringify(config, null, 2));
    await repo.add();
    await repo.commit();
  } catch (err) {
    console.log(err);
  }

  deploying: {
    (0, _utils.print)('Creating Release...');
    let release = await (0, _createRelease.createRelease)({
      name: null
      /* TODO */
      ,
      required: adapter.requiresRelease
    });

    if (release === false && adapter.requiresRelease) {
      (0, _utils.print)('Cancelling Deployment...');
      break deploying;
    }

    await adapter.deploy(name, deployment.options, release);
    (0, _utils.print)('Deployment Complete!');
  }

  (0, _utils.print)('Cleaning Up...');
  await _utils.fs.rmdir(buildDestinations[platform]);
  await _utils.fs.rmdir('./dist');
  await repo.checkout(initialBranch);
};
//# sourceMappingURL=index.js.map