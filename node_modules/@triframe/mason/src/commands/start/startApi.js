'use strict';

const chokidar = require('chokidar');
const path = require('path');
const babel = require('@babel/core');
const fs = require('fs');
const os = require('os');
const fork = require('child_process').fork;
const execSync = require('child_process').execSync;
const debounce = require('lodash.debounce');
const isString = require('lodash.isstring');
const isArray = require('lodash.isarray');
const isRegExp = require('lodash.isregexp');

const RESTART_COMMAND = 'rs';
const DEBOUNCE_DURATION = 100; //milliseconds

export const startApi =  () => {

  const program = {
    watch: './src',
    args: [ './src/Api.js' ]
  }

  // Plucked directly from old Babel Core
  // https://github.com/babel/babel/commit/0df0c696a93889f029982bf36d34346a039b1920
  function regexify(val) {
    if (!val) return new RegExp;
    if (isArray(val)) val = val.join("|");
    if (isString(val)) return new RegExp(val || "");
    if (isRegExp(val)) return val;
    throw new TypeError("illegal type for regexify");
  };

  function arrayify(val) {
    if (!val) return [];
    if (isString(val)) return (val ? val.split(',') : []);
    if (isArray(val)) return val;
    throw new TypeError("illegal type for arrayify");
  };  

  const cwd = process.cwd();

  let only, ignore;


  if (program.only != null) only = arrayify(program.only, regexify);
  if (program.ignore != null) ignore = arrayify(program.ignore, regexify);

  let transpileExtensions = babel.DEFAULT_EXTENSIONS;

  if (program.extensions) {
    transpileExtensions = transpileExtensions.concat(arrayify(program.extensions));
  }

  const mainModule = program.args[0] || 'index.js';
  if (!mainModule) {
    console.error('Main script not specified');
    process.exit(1);
  }
  if (!mainModule.startsWith('.') && !mainModule.startsWith('/')) {
    program.args[0] = path.join(cwd, mainModule);
  }

  let childApp, pipeFd, pipeFilename;

  const cache = {};
  const errors = {};

  const watcher = chokidar.watch(program.watch, {
    persistent: true,
    ignored: program.exclude,
    ignoreInitial: true,
    usePolling: program.usePolling,
  });
  let watcherInitialized = (program.watch.length === 0);

  process.on('SIGINT', function () {
    watcher.close();
    killApp();
    process.exit(0);
  });

  const debouncedHandleChange = debounce(handleChange, DEBOUNCE_DURATION);

  watcher.on('change', debouncedHandleChange);
  watcher.on('add', debouncedHandleChange);
  watcher.on('unlink', debouncedHandleChange);

  watcher.on('ready', () => {
    if (!watcherInitialized) {
      watcherInitialized = true;
      restartApp();
    }
  });

  watcher.on('error', error => {
    console.error('Watcher failure', error);
    process.exit(1);
  });

  // Restart the app when a sequence of keys has been pressed ('rs' by refault)
  const stdin = process.stdin;
  stdin.setEncoding('utf8');
  stdin.on('data', (data) => {
    if (String(data).trim() === RESTART_COMMAND) {
      restartApp();
    }
  });

  function handleChange(file) {
    const absoluteFile = file.startsWith('/') ? file : path.join(cwd, file);
    delete cache[absoluteFile];
    delete errors[absoluteFile];

    // file is in use by the app, let's restart!
    restartApp();
  }

  function generateTempFilename() {
    const now = new Date();
    return path.join(os.tmpdir(), [
      now.getYear(), now.getMonth(), now.getDate(),
      '-',
      process.pid,
      '-',
      (Math.random() * 0x100000000 + 1).toString(36),
    ].join(''));
  }

  function handleFileLoad(filename, callback) {
    const cached = cache[filename];
    if (cached) {
      const stats = fs.statSync(filename);
      if (stats.mtime.getTime() === cached.mtime) {
        callback(cache[filename].code, cache[filename].map);
        return;
      }
    }
    if (!shouldIgnore(filename)) {
      compile(filename, (err, result) => {
        if (err) {
          console.error('Babel compilation error', err.stack);
          errors[filename] = true;
          return;
        }
        const stats = fs.statSync(filename);
        cache[filename] = {
          code: result.code,
          map: result.map,
          mtime: stats.mtime.getTime(),
        };
        delete errors[filename];
        callback(result.code, result.map);
      });
    } else {
      callback();
    }
  }

  function killApp() {
    if (childApp) {
      const currentPipeFd = pipeFd;
      const currentPipeFilename = pipeFilename;

      let hasRestarted = false;
      const restartOnce = () => {
        if (hasRestarted) return;
        hasRestarted = true;
        if (currentPipeFd) {
          fs.closeSync(currentPipeFd); // silently close pipe fd
        }
        if (pipeFilename) {
          fs.unlinkSync(pipeFilename); // silently remove old pipe file
        }
        pipeFd = undefined;
        childApp = undefined;
        pipeFilename = undefined;
        restartAppInternal();
      };
      childApp.on('exit', restartOnce);
      let isRunning = true;
      try {
        process.kill(childApp.pid, 0);
      } catch (e) {
        isRunning = false;
      }
      if (isRunning) {
        try {
          childApp.kill('SIGHUP');
        } catch (error) {
          childApp.kill('SIGKILL');
        }
        pipeFd = undefined;
        pipeFilename = undefined;
        childApp = undefined;
      } else {
        pipeFd = undefined;
        pipeFilename = undefined;
        childApp = undefined;
        restartOnce();
      }
    }
  }

  function prepareRestart() {
    if (watcherInitialized && childApp) {
      // kill app early as `compile` may take a while
      var restartMessage = program.message ? program.message : ">>> Restarting Api...";
      console.log(restartMessage);
      killApp();
    } else {
      restartAppInternal();
    }
  }

  function restartApp() {
    if (!watcherInitialized) return;
    prepareRestart();
  }

  function restartAppInternal() {
    if (Object.keys(errors).length != 0) {
      // There were some transpilation errors, don't start unless solved or invalid file is removed
      return;
    }

    pipeFilename = generateTempFilename();

    if (os.platform() === 'win32') {
      try {
        execSync(`echo. > ${pipeFilename}`);
      } catch (e) {
        console.error(`Unable to create file ${pipeFilename}`);
        process.exit(1);
      }
    } else {
      try {
        execSync(`mkfifo -m 0666 ${pipeFilename}`);
      } catch (e) {
        console.error('Unable to create named pipe with mkfifo. Are you on linux/OSX?');
        process.exit(1);
      }
    }

    // Support for --debug option
    const runnerExecArgv = process.execArgv.slice();
    if (program.debug) {
      runnerExecArgv.push(typeof (program.debug) === 'boolean'
        ? `--debug`
        : `--debug=${program.debug}`
      )
    }
    // Support for --debug-brk option
    if (program.debugBrk) {
      runnerExecArgv.push('--debug-brk');
    }
    // Support for --inspect option
    if (program.inspect) {
      // Somehow, the default port (2992) is being passed from the node command line. Wipe it out.
      const inspectArg = typeof (program.inspect) === 'boolean'
        ? `--inspect`
        : `--inspect=${program.inspect}`
      runnerExecArgv.push(inspectArg);
    }
    // Support for --inspect-brk option
    if (program.inspectBrk) {
      const inspectBrkArg = typeof (program.inspectBrk) === 'boolean'
        ? `--inspect-brk`
        : `--inspect-brk=${program.inspectBrk}`
      runnerExecArgv.push(inspectBrkArg)
    }

    const app = fork(path.resolve(__dirname, '__runner__.js'), { execArgv: runnerExecArgv });

    app.on('message', (data) => {
      if (!data || data.event !== 'babel-watch-filename') return;
      const filename = data.filename;
      if (!program.disableAutowatch) {
        // use relative path for watch.add as it would let chokidar reconsile exclude patterns
        const relativeFilename = path.relative(cwd, filename);
        watcher.add(relativeFilename);
      }
      handleFileLoad(filename, (source, sourceMap) => {
        const sourceBuf = source ? Buffer.from(source) : Buffer.alloc(0);
        const mapBuf = sourceMap ? Buffer.from(JSON.stringify(sourceMap)) : Buffer.alloc(0);
        const lenBuf = Buffer.alloc(4);
        if (pipeFd) {
          try {
            lenBuf.writeUInt32BE(sourceBuf.length, 0);
            fs.writeSync(pipeFd, lenBuf, 0, 4);
            sourceBuf.length && fs.writeSync(pipeFd, sourceBuf, 0, sourceBuf.length);

            lenBuf.writeUInt32BE(mapBuf.length, 0);
            fs.writeSync(pipeFd, lenBuf, 0, 4);
            mapBuf.length && fs.writeSync(pipeFd, mapBuf, 0, mapBuf.length);
          } catch (error) {
            // EPIPE means `pipeFd` has been closed. We can ignore this
            if (error.code !== 'EPIPE') {
              throw error;
            }
          }
        }
      });
    });

    app.send({
      event: 'babel-watch-start',
      pipe: pipeFilename,
      args: program.args,
      handleUncaughtExceptions: !program.disableExHandler,
      transpileExtensions: transpileExtensions,
    });
    pipeFd = fs.openSync(pipeFilename, 'w');
    childApp = app;
  }

  function shouldIgnore(filename) {
    if (transpileExtensions.indexOf(path.extname(filename)) < 0) {
      return true;
    } else if (!ignore && !only) {
      // Ignore node_modules by default
      return path.relative(cwd, filename).split(path.sep).indexOf('node_modules') >= 0;
    } else {
      return babel.util.shouldIgnore(filename, ignore || [], only);
    }
  }


  function compile(filename, callback) {
    const optsManager = new babel.OptionManager;



    const opts = optsManager.init({ filename });
    // Do not process config files since has already been done with the OptionManager
    // calls above and would introduce duplicates.
    opts.babelrc = false;
    opts.sourceMaps = true;
    opts.ast = false;
    opts.presets = [require('babel-preset-triframe')]
    opts.plugins = []

    return babel.transformFile(filename, opts, (err, result) => {
      callback(err, result);
    });
  }

  restartApp()
}
