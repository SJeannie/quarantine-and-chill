"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.serialize = undefined;

var _core = require("@triframe/core");

var _core2 = require("./core");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const primativeTypes = ['String', 'Boolean', 'Number', 'Date', 'Function'];
const skippedPrototypes = [Object.prototype, Function.prototype, _core.Resource.prototype, _core.Resource, _core.EventEmitter.prototype, undefined, null];

const skippedProperties = target => typeof target === 'function' ? ['length', 'name', 'prototype'] : ['constructor', '[[attributes]]', '[[patches]]', '[[base]]', '[[batch]]', '[[validationState]]'];

const serialize = exports.serialize = function ($interface, config = {}) {
  const io = new _core.EventEmitter();

  const main = () => {
    if (!isObject($interface)) throw Error('$interface must be a plain JavaScript Object');
    let schema = serializeObject('global', $interface);
    Object.defineProperty(schema, 'emit', {
      enumerable: false,
      value: (...args) => io.emit(...args)
    });
    return schema;
  };

  const serializeObject = function (name, object) {
    let descriptors = {};
    let $interface = {};

    for (let target = object; !skippedPrototypes.includes(target); target = target.__proto__) {
      (0, _core.each)(Object.getOwnPropertyDescriptors(target), (key, descriptor) => {
        if (!skippedProperties(target).includes(key)) {
          $interface[key] = object[key];
          descriptors[key] = descriptor;
        }
      });
    }

    return {
      type: 'object',
      attributes: (0, _core.map)($interface, (key, value) => {
        const descriptor = descriptors[key];
        const metadata = (0, _core.getMetadata)(object, key);
        if (isClass(value, descriptor)) return serializeClass(`${name}/${key}`, value, descriptor, metadata, object, key);
        if (isObject(value, descriptor)) return serializeObject(`${name}/${key}`, value, descriptor, metadata, object, key);
        if (isFunction(value, descriptor)) return serializeFunction(`${name}/${key}`, value, descriptor, metadata, object, key);
        if (isProperty(value, descriptor)) return serializeProperty(`${name}/${key}`, value, descriptor, metadata, object, key);
        if (isAttribute(value, descriptor)) return serializeAttribute(`${name}/${key}`, value, descriptor, metadata, object, key);
      })
    };
  };

  const serializeClass = function (name, Class) {
    const instance = new Class();
    return {
      name,
      type: 'class',
      className: Class.name,
      classMethods: serializeMethods(name, Class),
      instanceMethods: serializeMethods(`${name}/#`, instance)
    };
  };

  const serializeMethods = function (name, object) {
    let descriptors = {};

    for (let target = object; !skippedPrototypes.includes(target); target = target.__proto__) {
      (0, _core.each)(Object.getOwnPropertyDescriptors(target), (key, descriptor) => {
        if (!skippedProperties(target).includes(key)) {
          descriptors[key] = descriptor;
        }
      });
    }

    return (0, _core.map)(descriptors, (key, descriptor) => {
      const metadata = (0, _core.getMetadata)(object, key);
      if (isObject(descriptor.value, descriptor)) return serializeObject(`${name}/${key}`, descriptor.value, descriptor, metadata, object, key);
      if (isFunction(descriptor.value, descriptor)) return serializeFunction(`${name}/${key}`, descriptor.value, descriptor, metadata, object, key);
      if (isProperty(descriptor.value, descriptor)) return serializeProperty(`${name}/${key}`, descriptor.value, descriptor, metadata, object, key);
      if (isAttribute(descriptor.value, descriptor)) return serializeAttribute(`${name}/${key}`, descriptor.value, descriptor, metadata, object, key);
    });
  };

  const serializeFunction = function (name, value, descriptor, metadata, parent) {
    const {
      isShared,
      readAccessTest,
      usesSession,
      isStream,
      original
    } = metadata;

    if (isShared) {
      return {
        isStream,
        name,
        type: 'shared-function',
        value: isStream ? original.toString() : value.toString()
      };
    } else {
      io.on(name, async ({
        args,
        uid,
        attributes,
        patches,
        socket,
        send,
        onClose
      }) => {
        socket.cache = socket.cache || (0, _core2.createCache)(socket);
        const {
          session
        } = socket;
        let resource;
        if (uid) resource = await socket.cache.getCached(uid);else resource = typeof parent === 'function' ? parent : new parent.constructor(attributes);
        let {
          updateSuccessful,
          invalidPatches
        } = await (0, _core2.updateResource)(resource, patches, session);

        if (!updateSuccessful) {
          return send({
            error: true,
            invalidPatches,
            message: 'You are not authorized to update the resource as requested'
          });
        }

        if (readAccessTest !== undefined && !(await readAccessTest.call(resource, {
          session,
          resource
        }))) {
          return send({
            error: true,
            message: 'You are not authorized to call this method'
          });
        }

        let result,
            methodSession,
            accessSession = socket.session.createSlice();

        const sendSerialized = async (value, keepOpen) => {
          //console.trace(name, value)
          if (usesSession) {
            methodSession.checkIntegrity();
          }

          const cache = socket.cache;
          const session = accessSession;

          const callback = () => sendSerialized(value, keepOpen);

          let serialized = await serializeDocument(value, {
            cache,
            session,
            callback
          });
          send(serialized, keepOpen);
        };

        if (usesSession) {
          methodSession = socket.session.createSlice();
          args.unshift(methodSession);
        }

        let run = () => {
          if (result && result.destroy) result.destroy();

          try {
            result = value.apply(resource, args);
          } catch (err) {
            send({
              error: true,
              message: err.message,
              callstack: Error.captureStackTrace(err)
            });
          }

          if (result && result.catch) result.catch(err => {
            // Error.captureStackTrace(err)
            send({
              error: true,
              message: err.message,
              callstack: err.stack
            });
          });

          if (isPipe(result)) {
            if (usesSession) methodSession.onChange(() => {
              result.forceReload();
            });
            result.observe(value => sendSerialized(value, true));
            socket.onClose(() => {
              result.destroy();
              if (methodSession) methodSession.removeListeners();
              if (accessSession) accessSession.removeListeners();
            });
          } else if (isPromise(result)) {
            result.then(value => sendSerialized(value));
          } else {
            sendSerialized(result);
          }
        };

        run();
      });
      return {
        name,
        type: 'remote-function'
      };
    }
  };

  const serializeProperty = function (name, value, descriptor, metadata, object, key) {
    const {
      validators
    } = metadata;
    return {
      name,
      key: key,
      type: 'property',
      enumerable: descriptor.enumerable,
      get: serializeFunction(`${name}.get`, descriptor.get || (() => null), descriptor, metadata, object),
      set: serializeFunction(`${name}.set`, descriptor.set || (() => null), descriptor, metadata, object),
      validators: validators && validators.map(validator => validator.toString())
    };
  };

  const serializeAttribute = function (name, value, descriptor, metadata, object, key) {
    const {
      validators
    } = metadata;
    return {
      name,
      key: key,
      type: 'attribute',
      value: descriptor.value,
      validators: validators && validators.map(validator => validator.toString())
    };
  };

  return main();
};

const isPrimative = value => primativeTypes.includes(value.constructor.name);

const isDateTime = value => value.isLuxonDateTime === true;

const isClass = value => typeof value === 'function' && isDocument(value.prototype);

const isDocument = value => value instanceof _core.Resource;

const isArray = value => Array.isArray(value);

const isObject = value => value && value.__proto__ === Object.prototype;

const isFunction = value => typeof value === 'function' && !isClass(value);

const isProperty = (value, descriptor) => typeof descriptor.get === 'function' || typeof descriptor.set === 'function';

const isAttribute = (value, descriptor) => [isClass, isObject, isFunction, isProperty].every(isType => !isType(value, descriptor));

const isPipe = value => value && typeof value.observe == 'function';

const isPromise = value => value && typeof value.then == 'function' && !isPipe(value);

const serializeDocument = async function (document, {
  cache,
  session,
  callback
}) {
  const next = document => serializeDocument(document, {
    cache,
    session,
    callback
  });

  if (!document) return document;
  if (isDateTime(document)) return document;
  if (isClass(document)) return {
    _class_: document.name
  };
  if (isPrimative(document)) return document;
  if (isArray(document)) return await Promise.all(document.map((element, index) => next(element)));
  if (isObject(document)) return await (0, _core.mapAsync)(document, (propertyName, object) => next(object));
  cache.cache(document);
  if (isDocument(document)) return _objectSpread(_objectSpread({}, await (0, _core.mapAsync)(document['[[attributes]]'], async (propertyName, propertyValue) => {
    const metadata = (0, _core.getMetadata)(document, propertyName);
    const {
      readAccessTest,
      namespace
    } = metadata;

    if (readAccessTest === undefined) {
      return await next(propertyValue);
    } else {
      //session.onChange( callback )
      const resource = document;
      const result = readAccessTest.call(resource, {
        session,
        resource
      });
      if (result instanceof Promise) console.warn(`Running Asynchronous Authentication Checks for ${namespace} during serailization`);
      if (!(await result)) return null;else return await next(propertyValue);
    }
  })), {}, {
    _proto_: document.constructor.name
  });
};
//# sourceMappingURL=serialize.js.map