"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createUnserializer = undefined;

var _core = require("@triframe/core");

var core = _interopRequireWildcard(_core);

var _core2 = require("./core");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

const {
  each,
  map,
  Pipe,
  Resource,
  List,
  DateTime,
  Duration
} = core;
const primativeTypes = ['String', 'Boolean', 'Number', 'Date', 'Function', 'DateTime'];

const createUnserializer = exports.createUnserializer = io => {
  const cache = createCache({
    socket: io
  });
  const classes = {
    Resource,
    List,
    DateTime,
    Duration
  };

  const unserialize = schema => {
    if (typeof schema !== 'object') throw Error('schema must be a plain JavaScript Object');
    return unserializeObject(classes, schema.attributes);
  };

  const unserializeClass = schema => {
    const Class = class extends Resource {};
    Object.defineProperty(Class, 'name', {
      value: schema.className
    });
    unserializeObject(Class, schema.classMethods);
    unserializeObject(Class.prototype, schema.instanceMethods);
    return Class;
  };

  const unserializeObject = (target, schema) => {
    each(schema, (key, schema) => {
      switch (schema.type) {
        case 'class':
          target[key] = unserializeClass(schema);
          break;

        case 'object':
          target[key] = unserializeObject({}, schema.attributes);
          break;

        case 'shared-function':
          target[key] = unserializeSharedFunction(schema);
          break;

        case 'remote-function':
          target[key] = unserializeRemoteFunction(schema);
          break;

        case 'property':
          unserializeProperty(target, key, schema);
          break;

        case 'attribute':
          target[key] = unserializeAttribute(schema, target);
          break;
      }
    });
    return target;
  };

  const unserializeFunction = schema => {
    switch (schema.type) {
      case 'shared-function':
        return unserializeSharedFunction(schema);
        break;

      case 'remote-function':
        return unserializeRemoteFunction(schema);
        break;
    }
  };

  const unserializeSharedFunction = schema => {
    const {
      isStream,
      prependEmit,
      value
    } = schema;
    let func = new Function('_core', `return ${value}`)(core);
    return !isStream ? func : createStream(func, prependEmit);
  };

  function createStream(method) {
    const process = function (emit, ...args) {
      return method.call(this, ...args, emit);
    };

    return function (...args) {
      return new Pipe([this, process], ...args);
    };
  }

  const unserializeRemoteFunction = schema => {
    const {
      name
    } = schema;

    const remoteProcess = function (emit, args) {
      let uid, attributes, patches;

      if (typeof this !== 'undefined') {
        ({
          uid
        } = this);
        attributes = this['[[attributes]]'];
        patches = (0, _core2.stageNewPatches)(this);
      } else {
        uid = null;
        attributes = {};
        patches = [];
      }

      let document;

      let emitDocument = () => emit(document);

      const emitUnserialized = value => {
        if (value && value.error) {
          // TO DO: Remove invalid patches from the resources patches
          value.invalidPatches;
          let error = new Error(value.message);
          error.stack = value.callstack;
          return emit.throw(error);
        } //if(keepOpen) createSubscription(keepOpen)


        document = unserializeDocument(value, emitDocument);
        emit(document);
      };

      const sendRequest = () => {
        io.emit(name, {
          uid,
          patches,
          args
        }, emitUnserialized);
      };

      const createSubscription = hook => {
        io.on(hook, emitUnserialized); // If the server or connection fuck up, 
        //  1. stop listening for the old event, and
        //  2. re-send the request to re-establish connection
        // TODO: Worry about a server re-start causing a ton of requests, crashing
        //  browsers and/or the server
        // const reconnectHandler = () => {
        //     console.log(name)
        //     io.removeEventListener('reconnect', reconnectHandler)
        //     io.removeEventListener(hook, emitUnserialized)
        //     sendRequest()
        // }
        // io.on('reconnect', reconnectHandler)
        // If this pipe is destroyed (user goes to another page, etc.), 
        // tell the server to cancel the subscription and stop listening for it

        emit.pipe.onCancel(() => {
          io.removeEventListener(hook, emitUnserialized);
          io.emit(`${hook}.destroy`);
        });
      };

      sendRequest();
    };

    return function (...args) {
      return new Pipe([this, remoteProcess], args);
    };
  };

  const unserializeProperty = (target, key, schema) => {
    const {
      validation
    } = target;

    if (validation && schema.validators) {
      schema.validators.forEach(validator => {
        validation.addHandler(schema.key, unserializeSharedFunction({
          value: validator
        }));
      });
    }

    Object.defineProperty(target, key, {
      enumerable: schema.enumerable,
      get: unserializeFunction(schema.get),
      set: unserializeFunction(schema.set)
    });
  };

  const unserializeAttribute = (schema, target) => {
    const {
      validation
    } = target;

    if (validation && schema.validators) {
      schema.validators.forEach(validator => {
        validation.addHandler(schema.key, unserializeSharedFunction({
          value: validator
        }));
      });
    }

    return schema.value;
  };

  const unserializeDocument = (document, callback) => {
    const next = document => unserializeDocument(document, callback);

    if (!document) return document;
    if (primativeTypes.includes(document.constructor.name)) return document;
    if (Array.isArray(document)) return new List(...document.map(document => next(document)));
    if (document instanceof DateTime) return document;
    if (document instanceof Duration) return document;

    const {
      _class_,
      _proto_
    } = document,
          attributes = _objectWithoutProperties(document, ["_class_", "_proto_"]);

    if (_class_) return classes[_class_];
    if (_proto_) return cache.register(new classes[_proto_](map(attributes, (key, value) => next(value))), callback);
    return map(attributes, (key, value) => next(value));
  };

  return unserialize;
};

const createCache = ({
  socket
}) => {
  let bin = {};
  window.bin = bin;

  function register(resource = {}, callback) {
    if (!bin[resource.uid]) {
      function emit() {
        bin[resource.uid].callbacks.forEach(callback => callback());
      }

      resource.on('Δ.change', () => emit());
      resource.on('Δ.sync', ({
        patches
      }) => {
        let batchId = (0, _core2.createBatch)(resource);
        socket.emit(`${resource.uid}.sync`, {
          patches,
          batchId
        }, ({
          updateSuccessful,
          invalidPatches
        }) => {
          if (!updateSuccessful) {
            (0, _core2.rollbackPatches)(resource, invalidPatches);
            resource.emit('Δ.changed');
            emit();
          }
        }); // emit()
      });
      socket.on(`${resource.uid}.mergeBatch`, batchId => {
        (0, _core2.mergeBatch)(resource, batchId);
      });
      socket.on(`${resource.uid}.mergePatches`, patches => {
        (0, _core2.mergePatches)(resource, patches);
        resource.emit('Δ.changed');
        emit();
      });
      bin[resource.uid] = {
        resource,
        callbacks: [callback]
      };
    } else {
      if (!bin[resource.uid].callbacks.includes(callback)) bin[resource.uid].callbacks.push(callback);
      (0, _core2.upstreamMerge)(bin[resource.uid].resource, resource);
      resource = bin[resource.uid].resource;
      resource.emit('Δ.changed');
    }

    return resource;
  }

  return {
    register
  };
};
//# sourceMappingURL=unserializer.js.map