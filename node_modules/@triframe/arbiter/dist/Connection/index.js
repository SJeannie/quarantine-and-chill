"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Connection = undefined;

var _ws = require("./ws");

var _cookie = require("cookie");

var _cookie2 = _interopRequireDefault(_cookie);

var _Base = require("./Base");

var _createSession = require("./createSession");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

let id = 0;
const connections = {};

const store = connection => {
  connections[++id] = connection;
  return id;
};

const unstore = id => {
  delete connections[id];
};

class Connection extends _Base.ConnectionBase {
  constructor(ws) {
    super();

    _defineProperty(this, "closeListeners", []);

    let id = store(this);
    this.id = id;
    this.bind(ws);
    this.emit('__id__', id);
    this.clientSecret = ws.clientSecret;
    ws.addEventListener('close', () => {
      //unstore(id)
      this.cancelationTimeout = setTimeout(() => {
        this.closeListeners.forEach(l => l());
      });
    });
  }

  get session() {
    return this.sessionHead ? this.sessionHead.createSlice() : null;
  }

  onClose(listener) {
    this.closeListeners.push(listener);
  }

  static listen(server, sessionModel, callback) {
    const Session = (0, _createSession.createSession)(sessionModel);
    const wss = new _ws.Server({
      server
    });
    wss.on('headers', establishClientSecret);
    wss.on('connection', ws => {
      ws.addEventListener('message', establishConnection);
    });

    function establishClientSecret(headers, request, ws) {
      let {
        clientSecret
      } = _cookie2.default.parse(request.headers.cookie || '');

      if (!clientSecret) {
        clientSecret = createSecret();
        headers.push(`Set-Cookie: ${_cookie2.default.serialize('clientSecret', clientSecret)}`);
      }

      ws.clientSecret = clientSecret;
    }

    async function establishConnection({
      data,
      target
    }) {
      const [strategy, identifier] = data.split(' ');

      switch (strategy) {
        case 'initialize':
          target.removeEventListener('message', establishConnection);
          let connection = new Connection(target);
          connection.sessionHead = await Session.loadFor(connection);
          callback(connection);
          break;

        case 'mount':
          target.removeEventListener('message', establishConnection);
          if (connections[identifier]) connections[identifier].bind(target);else target.send('["__reload__"]');
          break;
      }
    }
  }

}

exports.Connection = Connection;

function createSecret() {
  var result = '';
  var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  var charactersLength = characters.length;

  for (var i = 0; i < 40; i++) {
    result += characters.charAt(Math.floor(Math.random() * charactersLength));
  }

  return result;
}
//# sourceMappingURL=index.js.map