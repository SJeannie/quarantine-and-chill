"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ConnectionBase = undefined;

var _core = require("@triframe/core");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class ConnectionBase extends _core.EventEmitter {
  constructor() {
    super();

    _defineProperty(this, "handleMessage", ({
      data
    }) => {
      try {
        const [event, payload, id, ...receipts] = JSON.parse(data, (key, value) => {
          if (value && value._date_ !== undefined) return value._date_ === null ? null : _core.DateTime.fromISO(value._date_);
          if (value && value._duration_ !== undefined) return value._duration_ === null ? null : _core.Duration.fromISO(value._duration_);
          return value;
        });
        this.timeLastReceived = Date.now();
        const nextMessageId = this.inboxId + 1;
        const respond = this.createRespond(id);
        receipts.forEach(this.removeFromOutbox);

        if (parseInt(id) === nextMessageId) {
          this.receipts.push(id);
          this.inboxId = id;
          super.emit(event, payload, respond);
          this.resolveInbox();
        } else if (id !== undefined && id !== null) {
          this.receipts.push(id);
          this.saveToInbox(id, event, payload);
          this.requestMessage(nextMessageId);
        } else {
          super.emit(event, payload, respond);
        }
      } catch (err) {
        console.log('Un-parsed message:', data, err);
      }
    });

    _defineProperty(this, "resendMessage", id => {
      let message = this.outbox[id];
      this.socket.send(message);
    });

    _defineProperty(this, "removeFromInbox", id => {
      delete this.inbox[id];
    });

    _defineProperty(this, "removeFromOutbox", id => {
      delete this.outbox[id];
    });

    _defineProperty(this, "clearReceipts", () => {
      if (this.timeLastSent < Date.now() - 10000 && this.receipts.length > 0) {
        this.socket.send(JSON.stringify(["__ping__", null, null, ...this.getReceipts()]));
      }
    });

    _defineProperty(this, "storage", new MemoryStorage());

    this.timeLastSent = 0;
    this.timeLastReceived = 0;
    this.inboxId = 0;
    this.outboxId = 0;
    this.outbox = {};
    this.inbox = {};
    this.receipts = [];
    this.on('__request_message__', this.resendMessage);
    this.clearReceiptsTimer = setInterval(this.clearReceipts, 10000);
  }

  bind(socket) {
    clearTimeout(this.cancelationTimeout);
    this.socket = socket;
    socket.addEventListener('message', this.handleMessage);
  }

  emit(event, payload, callback) {
    let id = ++this.outboxId;
    let message;

    try {
      message = JSON.stringify([event, payload, id, ...this.getReceipts()], (key, value) => {
        if (value instanceof _core.DateTime) return {
          _date_: value.toISO()
        };
        if (value instanceof _core.Duration) return {
          _duration_: value.toISO()
        };
        return value;
      });
    } catch (err) {
      console.log('Failed to encode payload', err);
    }

    this.saveToOutbox(id, message);
    this.socket.send(message);
    this.timeLastSent = Date.now();
    if (callback) this.on(`__response_${id}__`, callback);
  }

  requestMessage(id) {
    this.socket.send(JSON.stringify(["__request_message__", id]));
  }

  saveToInbox(id, event, payload) {
    this.inbox[id] = [event, payload];
  }

  saveToOutbox(id, message) {
    this.outbox[id] = message;
  }

  resolveInbox() {
    while (this.inbox[this.inboxId + 1] !== undefined) {
      let [event, payload] = this.inbox[++this.inboxId];
      let respond = this.createRespond(this.inboxId);
      super.emit(event, payload, respond);
      this.removeFromInbox(this.inboxId);
    }

    if (!isEmpty(this.inbox)) {
      this.requestMessage(this.inboxId + 1);
    }
  }

  getReceipts() {
    let result = this.receipts;
    this.receipts = [];
    return result;
  }

  createRespond(id) {
    return (payload, callback) => this.emit(`__response_${id}__`, payload, callback);
  }

  mountStorage(storage) {
    if (typeof storage.getItem !== 'function' || typeof storage.setItem !== 'function') throw Error('Attempted to mount invalid storage object');
    this.storage = storage;
  }

}

exports.ConnectionBase = ConnectionBase;

class MemoryStorage {
  getItem(name) {
    return this[name];
  }

  setItem(name, value) {
    this[name] = value;
  }

}

const isEmpty = obj => Object.keys(obj).length === 0;
//# sourceMappingURL=Base.js.map