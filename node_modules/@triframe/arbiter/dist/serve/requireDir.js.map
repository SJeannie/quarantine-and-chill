{"version":3,"sources":["../../src/serve/requireDir.js"],"names":["requireDir","fs","require","path","dir","opts","files","readdirSync","filesForBase","i","length","file","ext","extname","base","basename","push","map","extensions","hasOwnProperty","filesMinusDirs","abs","resolve","filter","statSync","isDirectory","shallow","startsWith","duplicates","test","module","default","mapKey","mapValue","newKey","newVal"],"mappings":"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","sourcesContent":["\r\nvar fs = require('fs');\r\nvar path = require('path');\r\n\r\nexport function requireDir(dir, opts) {\r\n    // default arguments:\r\n    dir = dir || '.';\r\n    opts = opts || {};    \r\n\r\n    // read the directory's files:\r\n    // note that this'll throw an error if the path isn't a directory.\r\n    var files = fs.readdirSync(dir);\r\n\r\n    // to prioritize between multiple files with the same basename, we'll\r\n    // first derive all the basenames and create a map from them to files:\r\n    var filesForBase = {};\r\n\r\n    for (var i = 0; i < files.length; i++) {\r\n        var file = files[i];\r\n        var ext = path.extname(file);\r\n        var base = path.basename(file, ext);\r\n        (filesForBase[base] = filesForBase[base] || []).push(file);\r\n    }\r\n\r\n    // then we'll go through each basename, and first check if any of the\r\n    // basenames' files are directories, since directories take precedence if\r\n    // we're recursing and can be ignored if we're not. if a basename has no\r\n    // directory, then we'll follow Node's own require() algorithm of going\r\n    // through and trying the require.extension keys in order. in the process,\r\n    // we create and return a map from basename to require()'d contents! and\r\n    // if duplicates are asked for, we'll never short-circuit; we'll just add\r\n    // to the map using the full filename as a key also.\r\n    var map = {};\r\n\r\n    // get the array of extensions we need to require\r\n    var extensions = [ '.js' ]\r\n\r\n    for (var base in filesForBase) {\r\n        // protect against enumerable object prototype extensions:\r\n        if (!filesForBase.hasOwnProperty(base)) {\r\n            continue;\r\n        }\r\n\r\n        // go through the files for this base and check for directories. we'll\r\n        // also create a hash \"set\" of the non-dir files so that we can\r\n        // efficiently check for existence in the next step:\r\n        var files = filesForBase[base];\r\n        var filesMinusDirs = {};\r\n\r\n        for (var i = 0; i < files.length; i++) {\r\n            var file = files[i];\r\n            var abs = path.resolve(dir, file);\r\n\r\n            // ignore the calling file:\r\n            // if (abs === parentFile) {\r\n            //     continue;\r\n            // }\r\n            // apply file filter:\r\n            if (opts.filter && !opts.filter(abs)) {\r\n                continue;\r\n            }\r\n\r\n            if (fs.statSync(abs).isDirectory()) {\r\n                if (!opts.shallow) {\r\n                    if (base === 'node_modules' || base.startsWith('__')) {\r\n                        continue;\r\n                    }\r\n\r\n                    map = { ...requireDir(abs, opts) };\r\n\r\n                    // if duplicates are wanted, key off the full name too:\r\n                    if (opts.duplicates) {\r\n                        map[file] = map[base];\r\n                    }\r\n                }\r\n            } else {\r\n                filesMinusDirs[file] = abs;\r\n            }\r\n        }\r\n\r\n        // if we're recursing and we already encountered a directory for this\r\n        // basename, we're done for this base if we're ignoring duplicates:\r\n        if (map[base] && !opts.duplicates) {\r\n            continue;\r\n        }\r\n\r\n        // otherwise, go through and try each require.extension key!\r\n        for (ext of extensions) {\r\n            // if a file exists with this extension, we'll require() it:\r\n            var file = base + ext;\r\n            var abs = filesMinusDirs[file];\r\n\r\n            if (abs) {\r\n                // ignore TypeScript declaration files. They should never be\r\n                // `require`d\r\n                if (/\\.d\\.ts$/.test(abs)) {\r\n                    continue;\r\n                }\r\n\r\n                // if duplicates are wanted, key off the full name always, and\r\n                // also the base if it hasn't been taken yet (since this ext\r\n                // has higher priority than any that follow it). if duplicates\r\n                // aren't wanted, we're done with this basename.\r\n                \r\n                let module = require(abs);\r\n\r\n                map[base] = module[base] || module.default\r\n            }\r\n        }\r\n    }\r\n\r\n    if (opts.mapKey || opts.mapValue) {\r\n        for (var base in map) {\r\n            // protect against enumerable object prototype extensions:\r\n            if (!map.hasOwnProperty(base)) {\r\n                continue;\r\n            }\r\n\r\n            var newKey = opts.mapKey ? opts.mapKey(map[base], base) : base;\r\n            var newVal = opts.mapValue ? opts.mapValue(map[base], newKey) : map[base];\r\n            delete map[base];\r\n            map[newKey] = newVal;\r\n        }\r\n    }\r\n    return map;\r\n};"],"file":"requireDir.js"}