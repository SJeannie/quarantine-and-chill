"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.serve = undefined;

var _serialize = require("./serialize");

var _core = require("@triframe/core");

var _scribe = require("@triframe/scribe");

var _Connection = require("./Connection");

var _fs = require("fs");

var _fs2 = _interopRequireDefault(_fs);

var _mime = require("mime");

var _mime2 = _interopRequireDefault(_mime);

var _ncp = require("ncp");

var _ncp2 = _interopRequireDefault(_ncp);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const path = require('path');

const express = require('express');

const {
  Server
} = require('http');

const expressCors = require('cors');

const bodyParser = require('body-parser');

const formidable = require('formidable');

const STORAGE_PATH = './.storage';
const UPLOADS_PATH = `${STORAGE_PATH}/uploads`;

if (!_fs2.default.existsSync(STORAGE_PATH)) {
  _fs2.default.mkdirSync(STORAGE_PATH);
}

if (!_fs2.default.existsSync(UPLOADS_PATH)) {
  _fs2.default.mkdirSync(UPLOADS_PATH);
}

const cors = config => expressCors((0, _core.deepMerge)({
  origin: function (origin, resolve) {
    if (origin && origin.includes('localhost') || !config.useWhiteList || config.clientWhitelist.includes(origin)) {
      resolve(null, origin);
    } else {
      resolve(null, '');
    }
  },
  credentials: true
}, config));

const httpRedirectMiddleware = (req, res, next) => {
  if (!req.hostname.includes('localhost') && req.headers['x-forwarded-proto'] === 'http') {
    res.redirect(`https://${req.hostname}${req.originalUrl}`);
  } else {
    next();
  }
};

const defaultConfig = {
  port: process.env.BACKEND_PORT || 8080,
  models: {},
  session: {},
  database: {
    user: process.env.DB_USER || 'Josephine',
    password: process.env.DB_PASSWORD || 'P00p!',
    database: process.env.DB_NAME || 'Josephine',
    port: process.env.DB_PORT || 5432
  },
  cors: {
    useWhiteList: process.env.USE_CORS_WHITE_LIST || true,
    clientWhitelist: process.env.CORS_WHITE_LIST || []
  }
};

class Api extends _core.EventEmitter {
  constructor(configOptions) {
    super();

    _defineProperty(this, "frontendHandler", (req, res) => {
      res.sendFile(path.resolve('./public/index.html'));
    });

    _defineProperty(this, "cdnHandler", (req, res) => {
      const path = req.url.replace('/cdn', `${UPLOADS_PATH}/`);
      const extension = path.split('.').pop();

      const stat = _fs2.default.statSync(path);

      const mimeType = _mime2.default.getType(extension);

      res.writeHead(200, {
        'Content-Type': mimeType,
        'Content-Length': stat.size
      });

      const readStream = _fs2.default.createReadStream(path);

      readStream.pipe(res);
    });

    _defineProperty(this, "cdnUploadHandler", (req, res) => {
      const form = new formidable.IncomingForm();
      const urls = [];
      form.parse(req, (err, fields, files) => {
        Object.values(files).forEach(file => {
          const extension = file.name.split('.').pop();
          const filepath = `${createToken()}.${extension}`;
          urls.push(`/cdn/${filepath}`);
          (0, _ncp2.default)(file.path, `${UPLOADS_PATH}/${filepath}`);
        }); // res.writeHead(200, { 'content-type': 'text/plain', 'Access-Control-Allow-Origin': '*' });

        res.end(JSON.stringify(urls));
      });
    });

    _defineProperty(this, "socketHandler", socket => {
      const {
        schema
      } = this;
      socket.on('*', (payload, send, event) => {
        schema.emit(event, _objectSpread(_objectSpread({}, payload), {}, {
          socket,
          send
          /*onClose*/

        }));
      });
      this.emit('connection', socket);
      socket.emit('install', schema);
    });

    let config = (0, _core.deepMerge)(defaultConfig, configOptions);
    let router = express();
    this.config = config;
    this.router = router;
    this.server = Server(router);
    this.models = config.models;
    this.schema = (0, _serialize.serialize)(this.models);
    this.boot();
  }

  async boot() {
    const {
      config,
      server
    } = this;
    await (0, _scribe.connect)(config.database);
    server.listen(config.port, () => {
      this.drawRoutes(); // <-- Draw routes after connection, allowing user defined routes to 
      //       supercede the frontendHandler

      console.log(`Listening on ${config.port}`);
    });
  }

  drawRoutes() {
    const {
      config,
      router,
      server,
      cdnUploadHandler,
      cdnHandler,
      frontendHandler,
      socketHandler
    } = this;
    const corsMiddleware = cors(config.cors);
    const jsonParserMiddleware = bodyParser.json();
    const urlEncodedParserMiddleware = bodyParser.urlencoded({
      extended: true
    });
    router.use(httpRedirectMiddleware);
    router.use(urlEncodedParserMiddleware);
    router.use(jsonParserMiddleware);
    router.use(corsMiddleware);
    router.use(express.static(path.resolve('./public')));
    router.post('/upload', cdnUploadHandler);
    router.get('/cdn*', cdnHandler);
    router.get('/*', frontendHandler);

    _Connection.Connection.listen(server, config.session, socketHandler);
  }

}

const serve = exports.serve = configOptions => {
  return new Api(configOptions);
}; // UTILS


const createToken = () => {
  var result = '';
  var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  var charactersLength = characters.length;

  for (var i = 0; i < 12; i++) {
    result += characters.charAt(Math.floor(Math.random() * charactersLength));
  }

  return result;
};